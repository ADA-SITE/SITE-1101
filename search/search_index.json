{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83c\udf93 SITE 1101: Principles of Information Systems","text":"<p>The course provides a general overview of what SITE students of the ADA University will study throughout their bachelor\u2019s program. It introduces the fundamentals of information technology and computer-based systems, including hardware, software, network, database, artificial intelligence, system analysis and design, programming, etc. The course was originally developed by Araz Yusubov and Nuraddin Sadili with iterations over the years.</p>"},{"location":"#fall-2025","title":"Fall 2025","text":"<p>This website was launched at the end of the Fall 2025 semester with the efforts of our great Teaching Assistants Nilufar Ismayilova, Rahida Asadli (see Lecture Notes), and Rahman Karimov (Website), as well as the guidance of the course instructors Rumiyya Alili and Ismayil Shahaliyev.</p>"},{"location":"#spring-2026","title":"Spring 2026","text":"<p>The course was taught by Ismayil Shahaliyev and Araz Yusubov. The website was migrated to <code>mkdocs</code> with updates for the ongoing semester. Project 4 was brought back with certain revision of the course content.</p>"},{"location":"#office-hours","title":"Office Hours","text":"<p>Students are required to consistently check the course Blackboard page for announcements. General-purpose questions useful to other students should be asked on Blackboard discussion page. For private matters, students should use email. See communication rules for further details. TA office hours for the semester will be shared on blackboard.</p>"},{"location":"#technological-requirements","title":"Technological Requirements","text":"<p>Students are to use their laptops to implement the class assignments. Github account, downloaded git version control system, and IDE (VSCode or Cursor) will also be needed. Additional requirements may be provided by the instructor during the semester.</p>"},{"location":"#deadline-policy","title":"Deadline Policy","text":"<p>Deadlines will never be extended. When submitting, a student must consider possible internet connection issues, uploaded file size, etc. Late submissions of one minute until thirty minutes will receive a 10% penalty, late submissions of thirty minutes until one day will receive a 25% penalty with no claim for bonuses (if there are any), late submissions of more than one day will receive zero.</p>"},{"location":"#participation","title":"Participation","text":"<p>Students are expected to review the material covered in class and come prepared for the next session\u2019s discussions. Participation will be encouraged through both general discussion questions and individual questions directed to selected students.<sup>1</sup> For excused absences (e.g. illnesses), a student must write an email with a document of proof to their advisor, who will inform the relevant instructors.</p>"},{"location":"#homeworks-and-projects","title":"Homeworks and Projects","text":"<p>The detailed instructions and grading criteria of homeworks and projects will be communicated to students during the semester. Students are expected follow the instructions and submit their assignments before the deadline. </p>"},{"location":"#examination","title":"Examination","text":"<p>You will have two exams: midterm and final. Both exams will be computer-based (unless noted otherwise) with questions of various types (e.g. multiple-choice, fill-in-the-blank, code/essay). More specific rules will be communicated to you before the exam.<sup>2</sup></p>"},{"location":"#study-materials","title":"Study Materials","text":"<p>Study materials will be shared with you on blackboard throughout the semester. Lecture Notes are available online for this course.</p> <ol> <li> <p>In case of difficulties in communication, you are encouraged to consult your academic advisor and seek psychological support.\u00a0\u21a9</p> </li> <li> <p>You are expected to be aware of the Exam Rules and Regulations. If you have special needs or health  issues, you are strongly recommended to contact the University\u2019s Student Academic Support Services well ahead of the examination date. It is your responsibility to manage conflicts in your schedule and notify your instructors about it at least two weeks before the examination date.\u00a0\u21a9</p> </li> </ol>"},{"location":"Lecture_Notes/01_intro/","title":"01. System, Engineering, Technology","text":"<p>Info</p> <ul> <li>Rahida Asadli, Ismayil Shahaliyev </li> <li>Oct 10 2025 / Dec 18 2025</li> </ul> <p>Cybernetics is the study of control, communication, and feedback in systems, a field developed by Norbert Wiener. During WWII, Weiner worked on predicting the future position of enemy aircraft: he realized that both the gun and the pilot form a feedback system are constantly correcting actions based on error and delay rather than following a fixed plan. This insight led him to extend control theory beyond machines to living systems, emphasizing self-regulation and adaptation under uncertainty. This way of thinking later influenced artificial intelligence and deep learning, where feedback from errors is used to adjust internal parameters and improve performance.</p> <p>System is a set of interrelated components working together toward a common goal by accepting inputs, processing them, and producing outputs. Control system is a system that continuously monitors outputs and uses feedback to adjust inputs or processes, maintaining the system's desired performance and stability.</p> <ul> <li>Input: The resources (data, materials, or energy) that enter the system.</li> <li>Process: The transformation mechanism that converts input into output.</li> <li>Output: The result produced by the system.</li> </ul>      By Me (Intgr) - Own work, Public Domain, Link <p>Note</p> <p>In a home heating system, the desired room temperature is the input, the furnace heating the air is the process, and the warm air circulating through the house is the output. Feedback comes from a thermostat, which senses the actual temperature and switches the furnace on or off to keep the room at the set temperature.</p> <ul> <li>Input. Industrial materials (steel cables, stone, and concrete) and human expertise.</li> <li>Process. Design, testing, construction using pneumatic caissons, and ongoing adjustment based on feedback.</li> <li>Output. A stable, functional bridge that connected Manhattan and Brooklyn.</li> <li>Feedback. Design improvements (such as hybrid cable systems) and safety checks during construction.</li> </ul> <p>Note</p> <p>In the mid-19th century, several suspension bridges across Europe failed due to poor system design - weak materials and unpredictable environmental conditions. When John Roebling proposed the Brooklyn Bridge, he applied engineering systems thinking to overcome these failures.  Roebling's bridge demonstrates how system components and interactions determine reliability and success. When one subsystem (e.g., faulty cables) failed, built-in redundancies maintained the system's stability - an example of system resilience and feedback control in practice.</p> <p>Engineering (from Latin ingenium: cleverness) is the creative application of scientific principles to design, build, operate, and predict the behavior of structures, machines, processes, or systems in a safe and efficient manner to achieve a specific objective.</p> <p>Technology (from ancient Greek \u03c4\u03ad\u03c7\u03bd\u03b7 + \u03bb\u03bf\u03b3\u03af\u03b1 = techne + logia: science + art, skill) is the application of techniques, skills, methods, and processes to produce goods and services or achieve specific objectives.</p> <p>Data (plural, from Latin datum - something given) are raw facts, figures, or symbols without context or interpretation. They represent unprocessed observations and have little meaning on their own. Information is data that has been processed, organized, or structured in a way that gives it context and meaning. Knowledge is the understanding, insight, and experience gained from interpreting and applying information.</p> <p>Note</p> <p>Data: \"30,\" \"32,\" \"31\" just raw numbers with no context. Information: \"The temperatures recorded over three days were 30\u00b0C, 32\u00b0C, and 31\u00b0C.\" - now the data has context and meaning. Knowledge: \"Since temperatures above 30\u00b0C increase water evaporation, watering plants in the early morning is more effective.\" - applying the information to guide action.</p> <p>Context is the background, circumstances, or setting that gives meaning to data, information, or events. It allows us to interpret and understand facts correctly by showing how they relate to one another and to the situation in which they occur.</p> <p>Note</p> <p>Numbers like 1, 4, 9, 16, and 25 by themselves are just data. Without context, our experience may lead us to assume they are the squares of numbers from 1 to 5. But such a quick pattern recognition may mislead us once the context is given that these numbers represent the quantity of ice cream sold in a small grocery store on five different days. Context gives data its true significance and turns it into meaningful information.</p> <p>Information system is a set of interrelated components that collect, process, store, disseminate data and information, provides a feedback mechanism to monitor and control its operation to make sure it continues to meet its goals and objectives.</p> <p>Note</p> <p>A library information system records books (input), organizes and catalogs them (process), provides search results for users (output), and updates records based on borrowing activity (feedback).</p> <p>Computer-Based Information System is a single set of</p> <ul> <li>hardware,</li> <li>software,</li> <li>databases,</li> <li>telecommunications,</li> <li>people, and</li> <li>procedures</li> </ul> <p>that are configured to collect, manipulate, store, and process data into information.</p> <p>Note</p> <p>An online banking system takes transaction requests as input, processes them through secure software, and provides account balances or confirmations as output. Feedback such as error alerts or user actions improves future transactions and system reliability.</p>"},{"location":"Lecture_Notes/01_intro/#additional-material","title":"Additional Material","text":"<ul> <li>One of the most epic engineering feats in history</li> <li>How do Steam Engines Work?</li> <li>The Meaning of Knowledge</li> </ul>"},{"location":"Lecture_Notes/02_binary/","title":"02. Binary Representation, Arithmetic &amp; Logic Operations","text":"<p>Info</p> <ul> <li>Nilufar Ismayilova, Ismayil Shahaliyev</li> <li>Oct 23 2025 / Dec 19 2025</li> </ul>"},{"location":"Lecture_Notes/02_binary/#digital-vs-analog","title":"Digital vs Analog","text":"<p>Discrete means values change in separate, well-defined steps with no possible values in between. A standard light switch is a simple example: it is either on or off\u2014there is nothing between those two states. Likewise, a digital clock that shows 14:35 jumps straight to 14:36 with no \u201cin-between\u201d time displayed.</p> <p>Continuous means values can vary smoothly and without breaks over a range. Between any two values, there are infinitely many possible intermediate values. A classic example is a mercury thermometer: if the temperature is 21\u00b0C and then rises to 22\u00b0C, it passes through 21.1\u00b0C, 21.11\u00b0C, 21.111\u00b0C, and so on. The temperature does not \u201cjump\u201d from one reading to another; it changes continuously.</p> <p>This distinction is why digital systems are far more reliable than analog ones. In a continuous analog system, even a tiny fluctuation\u2014temperature drift or electrical noise\u2014can change the value. In a discrete digital system, as long as the signal is close enough to one of the two states (for example, above 3V is \u201c1\u201d and below 1V is \u201c0\u201d), the system will interpret it correctly. This tolerance to noise is why modern computers rely almost entirely on discrete binary states.</p> <p>Note</p> <p>In an analog system, numbers 3 and 5 could be represented by physical quantities such as voltage levels of 3V and 5V. To add them, the machine might combine the voltages to produce 8V. But if noise shifts levels by just 0.2V, the output might become 7.8V or 8.2V, which no longer corresponds exactly to 8. Repeated operations would accumulate these errors, making the result unreliable.</p> <p>The solution was to abandon continuous analog representation in favor of discrete digital states. Digital circuits only need to distinguish between a small set of clearly separated values, which makes them more reliable, scalable, and resistant to noise. Once that decision was made, the simplest and most robust choice was to use two discrete states. This directly matches what electronic components can reliably detect: current flowing or not, voltage high or low, transistor open or closed. Those two states are naturally represented by 0 and 1, forming the binary number system.</p>"},{"location":"Lecture_Notes/02_binary/#bit-byte-data-units","title":"Bit, Byte, Data Units","text":"<p>All digital information\u2014including instructions themselves\u2014is expressed as bits (binary digits, formally introduced by Claude Shannon in A Mathematical Theory of Communication). A bit is the smallest unit of data and can hold one of two values: 0 or 1. Every number, letter, image, or instruction is ultimately encoded as a sequence of bits.</p> <p>With two bits, there are 2\u00d72=4 possible combinations: 00, 01, 10, and 11. With three bits, there are 2\u00d72\u00d72=8 combinations: 000, 001, 010, 011, 100, 101, 110, and 111. In general, with N bits, the total number of combinations is 2^N. Each additional bit doubles the range of values that can be represented.</p> <p>Eight bits grouped together form a byte, the standard unit for representing a single character or a small piece of data. For example, the binary sequence <code>01000001</code> represents the letter \u201cA\u201d in ASCII. Larger quantities of data are measured in multiples of bytes: kilobytes (KB), megabytes (MB), gigabytes (GB), and beyond.</p> Data Unit Size Data Unit Size Bit (b) 1 Byte (B) 8 bits Kilobyte (KB) 10\u00b3 bytes Megabyte (MB) 10\u2076 bytes Gigabyte (GB) 10\u2079 bytes Terabyte (TB) 10\u00b9\u00b2 bytes Petabyte (PB) 10\u00b9\u2075 bytes Exabyte (EB) 10\u00b9\u2078 bytes Zettabyte (ZB) 10\u00b2\u00b9 bytes Yottabyte (YB) 10\u00b2\u2074 bytes <p>Exercise</p> <p>How many different colors can be represented in an RGB image if each of the three color channels (Red, Green, Blue) is stored using 8 bits?</p>"},{"location":"Lecture_Notes/02_binary/#number-systems","title":"Number Systems","text":"<p>Every piece of data inside a computer\u2014numbers, letters, images, even videos\u2014is represented using number systems. A number system defines how we represent and interpret numerical values using a specific set of symbols (digits) and a base that indicates how many symbols are available.</p> System Base Digits Used Example Usage Decimal (Base-10) 10 0\u20139 245\u2081\u2080 Everyday counting and arithmetic. Binary (Base-2) 2 0, 1 101101\u2082 Used internally by digital computers. Hexadecimal (Base-16) 16 0\u20139, A\u2013F 2AF\u2081\u2086 Memory addresses, machine code, colors, compact notation. <p>Decimal system (Base-10). Each position represents a power of 10.</p> <p>Example: 245\u2081\u2080 = (2\u00d710\u00b2) + (4\u00d710\u00b9) + (5\u00d710\u2070) = 200 + 40 + 5 = 245\u2081\u2080</p> <p>Binary system (Base-2). Each position represents a power of 2.</p> <p>Example: 1011\u2082 = (1\u00d72\u00b3) + (0\u00d72\u00b2) + (1\u00d72\u00b9) + (1\u00d72\u2070) = 8 + 0 + 2 + 1 = 11\u2081\u2080</p> <p>Hexadecimal system (Base-16). Uses 0\u20139 and A\u2013F for values 10\u201315. Each hex digit equals 4 binary bits.</p> <p>Example: 2AF\u2081\u2086 = (2\u00d716\u00b2) + (A\u00d716\u00b9) + (F\u00d716\u2070) = (2\u00d7256) + (10\u00d716) + (15\u00d71) = 687\u2081\u2080</p> Decimal Binary Hex Decimal Binary Hex 0 0000 0 8 1000 8 1 0001 1 9 1001 9 2 0010 2 10 1010 A 3 0011 3 11 1011 B 4 0100 4 12 1100 C 5 0101 5 13 1101 D 6 0110 6 14 1110 E 7 0111 7 15 1111 F <p>Note</p> <p>Decimal \u2192 Binary: Convert 13\u2081\u2080 by writing it as powers of two: 8+4+1=13. Hence 1101\u2082.</p> <p>Binary \u2192 Decimal: 1011\u2082 means 8+2+1=11, so it is 11\u2081\u2080.</p> <p>Binary \u2194 Hexadecimal: Group into 4-bit chunks: 10101110\u2082 = 1010 1110\u2082 = AE\u2081\u2086.</p> <p>Exercise</p> <p>Write down different numbers and convert back and forth between decimal, binary, and hexadecimal.</p>"},{"location":"Lecture_Notes/02_binary/#binary-arithmetic-and-twos-complement","title":"Binary Arithmetic and Two\u2019s Complement","text":"<p>Just like in the decimal system, numbers in binary can be added together. Since binary uses only 0 and 1, the addition rules are simple. Binary addition is a core operation performed by the Arithmetic Logic Unit (ALU) in a CPU.</p> Addition Result Carry 0 + 0 0 0 0 + 1 1 0 1 + 0 1 0 1 + 1 0 1 <p>In digital systems, subtraction is often performed using addition: A \u2212 B = A + (\u2212B)</p> <p>To make this work with the same adder circuit, computers represent negative numbers using two\u2019s complement.</p> <p>With 3 bits, there are 2\u00b3 = 8 different bit patterns. In unsigned representation, they represent 0 to 7.</p> <p>A na\u00efve \u201csign bit\u201d approach (one sign bit + magnitude bits) creates two zeros (+0 and \u22120) and breaks arithmetic in practice.</p> <p>Two\u2019s complement avoids these issues. With 3 bits, positives go from 000 (0) to 011 (3), and negatives go from 100 (\u22124) to 111 (\u22121). There is only one zero, and addition/subtraction works naturally.</p> <p>To find the negative of a number in two\u2019s complement: 1) invert the bits, 2) add 1, 3) discard any overflow carry.</p>"},{"location":"Lecture_Notes/02_binary/#example-1-positive-result","title":"Example 1: Positive result","text":"<p>A=7, B=5. Compute A\u2212B using 4-bit binary.[^1]</p> Step Operation Result 1 Write in binary A = 0111\u2082, B = 0101\u2082 2 Two\u2019s complement of B 0101 \u2192 1010 \u2192 1010 + 0001 = 1011\u2082 3 Add 0111 + 1011 = 10010\u2082 4 Discard carry 0010\u2082 5 Convert 2\u2081\u2080"},{"location":"Lecture_Notes/02_binary/#example-2-negative-result","title":"Example 2: Negative result","text":"<p>Compute 5\u22127 using 4-bit binary.</p> Step Operation Result 1 Write in binary 5 = 0101\u2082, 7 = 0111\u2082 2 Two\u2019s complement of 7 0111 \u2192 1000 \u2192 1000 + 0001 = 1001\u2082 3 Add 0101 + 1001 = 1110\u2082 4 Interpret as negative 1110\u2082 is negative in 4-bit two\u2019s complement 5 Magnitude (optional) 1110 \u2192 0001 \u2192 +1 = 0010\u2082 \u2192 2\u2081\u2080, so result is \u22122\u2081\u2080 <p>Exercise</p> <p>Subtract any two numbers in binary using two\u2019s complement.</p>"},{"location":"Lecture_Notes/02_binary/#transistors-and-moores-law","title":"Transistors and Moore\u2019s Law","text":"By Omegatron - \u00a0The SVG code is valid.\u00a0This symbol was created with Inkscape by user\u00a0Omegatron., CC BY-SA 3.0, Link <p>Modern computer chips contain billions of transistors packed into an area smaller than a fingernail. In 1965, Intel co-founder Gordon Moore observed that the number of transistors on a chip was roughly doubling every two years, which became known as Moore\u2019s Law (it is not a physical law). This trend made computers faster, smaller, and cheaper for decades.</p> <p>Transistor scaling has slowed due to physical and engineering constraints such as heat dissipation (power density), leakage currents at very small geometries, and the increasing difficulty and cost of manufacturing at nanometer scales.</p>"},{"location":"Lecture_Notes/02_binary/#boolean-logic","title":"Boolean Logic","text":"<p>All digital logic is based on Boolean algebra, named after George Boole. In this system, everything is either true or false, or in computer terms, 1 or 0.</p> <p>Three core operations are:</p> <ul> <li>NOT flips the value: 1\u21920 and 0\u21921.</li> <li>AND outputs 1 only if both inputs are 1.</li> <li>OR outputs 1 if at least one input is 1.</li> </ul> <p>These operations are implemented using logic gates. Every complex computation\u2014from addition to running software\u2014reduces to many fast gate operations.</p> <p> </p> A Q 0 1 1 0 <p>Figure: NOT logic gate symbol (Public Domain). Source: Wikimedia Commons.</p>"},{"location":"Lecture_Notes/02_binary/#and","title":"AND","text":"A B Q 0 0 0 0 1 0 1 0 0 1 1 1 <p>Figure: AND logic gate symbol (Public Domain). Source: Wikimedia Commons.</p>"},{"location":"Lecture_Notes/02_binary/#or","title":"OR","text":"A B Q 0 0 0 0 1 1 1 0 1 1 1 1 <p>Figure: OR logic gate symbol (Public Domain). Source: Wikimedia Commons.</p>"},{"location":"Lecture_Notes/02_binary/#xor","title":"XOR","text":"A B Q 0 0 0 0 1 1 1 0 1 1 1 0 <p>Figure: XOR logic gate symbol (Public Domain). Source: Wikimedia Commons.</p> <p>Note</p> <p>Exercise. How would you implement XOR using only NOT, AND, and OR? You can use an online digital logic simulator.</p> <p>Exercise. Use logic gates to add any two single-bit binary numbers. Which gates would you use? Hint: use the addition table above.</p>"},{"location":"Lecture_Notes/02_binary/#additional-material","title":"Additional Material","text":"<ul> <li>Early Computing: Crash Course Computer Science #1</li> <li>Electronic Computing: Crash Course Computer Science #2</li> <li>Boolean Logic &amp; Logic Gates: Crash Course Computer Science #3</li> <li>Binary: Plusses &amp; Minuses (Why We Use Two\u2019s Complement) - Computerphile</li> <li>Why It Was Almost Impossible to Make the Blue LED</li> </ul>"},{"location":"Lecture_Notes/03_hardware/","title":"03. Hardware \u2013 CPU, GPU, Memory, Storage Devices","text":"<p>Info</p> <ul> <li>Rahida Asadli, Ismayil Shahaliyev</li> <li>Oct 25 2025 / Dec 20 2025</li> </ul>"},{"location":"Lecture_Notes/03_hardware/#hardware","title":"Hardware","text":"<p>Hardware refers to the physical components of a computer system, the parts you can see and touch. It includes all electronic and mechanical elements that work together to input, process, store, and output data.</p> <p>Figure 1. Image of computer motherboard model DellT3600. Adapted from \u201cMotherboard,\u201d Wikipedia, Wikimedia Commons, https://en.wikipedia.org/wiki/Motherboard. Licensed under CC BY 2.5.</p> <p>The motherboard is the main circuit board and backbone of the computer, responsible for connecting and coordinating all hardware components. It provides electrical pathways (called buses) and controllers that allow the Central Processing Unit (CPU), memory, storage devices, input components (e.g. keyboard, mouse, microphone, scanner), and output components (e.g. monitor, printer, speaker) to communicate quickly and in the correct sequence. The motherboard ensures that data flows smoothly between these parts, much like a central highway system linking different parts of a city. The CPU socket is the slot where the processor is installed; through tiny metal contacts, it connects directly to the motherboard so the CPU can fetch, decode, and execute instructions from memory. Beside it are the memory slots, where Random-Access Memory (RAM) modules are inserted. RAM temporarily holds the data and instructions the CPU is currently working with, allowing fast access and efficient processing.</p> <p>Note</p> <p>Imagine you open the calculator app on your computer. When you click the icon, the action is sent through the motherboard. The calculator program is loaded into RAM, and the CPU begins reading its instructions from memory and carrying them out. When you type numbers, they are kept in RAM while the CPU performs the calculations. The result is then shown on the screen. If you close the app, the data in RAM is cleared, but the calculator program itself remains stored in a storage device for future use.</p>"},{"location":"Lecture_Notes/03_hardware/#von-neumann-architecture","title":"Von Neumann Architecture","text":"<p>The von Neumann architecture (1945) describes how most computers are structured. It consists of five key components. The input unit receives data and instructions from external devices. The memory unit stores data and instructions, either temporarily during processing or permanently for long-term use. The arithmetic logic unit performs arithmetic operations, such as addition and subtraction, as well as logical operations. The control unit directs and coordinates all system activities by controlling the flow of data and instructions between components. Finally, the output unit presents the processed information to the user or transmits it to other systems through output devices or communication interfaces.</p> <p>Figure 2. Diagram of the von Neumann architecture. Adapted from \u201cVon Neumann architecture,\u201d Wikipedia, Wikimedia Commons, https://en.wikipedia.org/wiki/Von_Neumann_architecture. Licensed under CC BY-SA 4.0.</p> <p>Both data and instructions are stored together in the same memory. This is called the stored-program concept. It was important because it allowed computers to keep programs in memory along with the data they use. This made it possible to change or run different programs by loading new instructions into memory, instead of manually changing the computer\u2019s hardware connections. It simplified computer design, enabled automation of complex tasks, and made programming far more flexible.</p> <p>It is common sense to us now, but only because it became the foundation of modern computing. Before the stored-program concept, computers like ENIAC had to be rewired by hand for every new task. There was no \u201cprogram\u201d to load\u2014the hardware was the program. John von Neumann\u2019s idea separated hardware (the machine) from software (the instructions it runs) and treated code as just another form of data. That shift made general-purpose computers possible.</p> <p>Note</p> <p>When you use a calculator app to add two numbers, both the program\u2019s instructions (load number, add, display result) and the numbers you enter are stored in RAM. The CPU retrieves and executes the instructions one by one, reads the data from memory, performs the addition, and writes the result back, following the stored-program model.</p>"},{"location":"Lecture_Notes/03_hardware/#central-processing-unit","title":"Central Processing Unit","text":"<p>Central Processing Unit (CPU) follows program instructions and performs the steps needed to complete tasks\u2014from typing a word to playing music. The CPU also controls and coordinates the work of other parts of the computer, making sure everything happens in the right order. A CPU consists of three main parts.</p> <p>Figure 3. A high-end consumer CPU made by Intel: an Intel Core i9-14900KF. Adapted from \u201cCentral processing unit,\u201d Wikipedia, Wikimedia Commons, https://en.wikipedia.org/wiki/Central_processing_unit. Licensed under CC BY 2.5.</p> <p>Control Unit (CU) manages and directs activities inside the CPU. It tells the computer when to fetch data, when to carry out an instruction, and where to send results. You can think of it as the traffic controller of the CPU.</p> <p>Arithmetic Logic Unit (ALU) performs arithmetic operations (addition, subtraction, multiplication, division) and logical operations (comparisons such as equal to, greater than, AND, OR, NOT). When the CPU executes an instruction like \u201cadd 2 + 3,\u201d the CU sends the task to the ALU. The ALU performs the calculation and sends the result back to registers or memory.</p> <p>Registers are tiny, high-speed memory locations built directly into the CPU. They store data and instructions temporarily during processing. Because they are inside the CPU, registers are much faster than RAM. Examples include:</p> <ul> <li>Instruction Register (IR) holds the current instruction being executed.</li> <li>Program Counter (PC) keeps track of the next instruction\u2019s address in memory.</li> <li>Accumulator (ACC) stores intermediate arithmetic and logic results.</li> </ul> <p>Every action the CPU performs follows four main steps, known as the machine cycle:</p> <ul> <li>Fetch: the CPU gets an instruction from RAM.</li> <li>Decode: the CPU determines what the instruction means.</li> <li>Execute: the CPU carries out the action (the ALU does the work).</li> <li>Store: the CPU saves the result back to memory or sends it to an output device.</li> </ul> <p>This process (fetch \u2192 decode \u2192 execute \u2192 store) repeats continuously, millions or billions of times per second.</p> <p>Note</p> <p>When a computer adds two numbers, several CPU components work together. First, the CU fetches the instruction from main memory (the binary code telling the CPU what to do). Then it decodes the instruction and identifies which data to use. After decoding, the CU sends control signals that tell the ALU to perform the operation and tell the registers when to load or output data.</p> <p>The ALU receives the numbers from registers, performs the addition in binary, and produces the result. Registers act as extremely fast storage locations: before the ALU starts, the inputs are placed in registers; after the ALU finishes, the output is stored in a register, ready to be written back to memory or used by the next instruction.</p> <p>Throughout the process, the CU enforces timing and order, ensuring that data moves only when it should. This coordination\u2014fetching, decoding, executing, and storing\u2014is what allows simple operations to happen reliably at very high speed.</p> <p>The clock is the timing system of the CPU. It sends out a steady stream of electrical pulses that set the pace for operations. The clock speed indicates how many cycles occur per second and is measured in Hertz (Hz). For example, a CPU with a 3.0 GHz clock runs about 3 billion cycles per second.</p> <p>Word size is the number of bits the CPU can process in one operation. The most common sizes are 32-bit and 64-bit. A 64-bit CPU can handle larger data chunks and can address much more memory than a 32-bit CPU.</p> <p>Modern CPUs contain multiple cores, meaning multiple processing units inside a single chip. Each core can run instructions independently, allowing parallel processing. A dual-core CPU can run two heavy tasks at once (for example, encoding a video while running a game), while lighter tasks can be managed by time-sharing even on a single core.</p> <p>Instruction Set Architecture (ISA) is the built-in language of the CPU. It defines the commands the CPU can understand and execute. The ISA specifies what operations exist and how programs interact with memory and hardware, while the microarchitecture describes how a particular CPU implements and executes those instructions internally. Common examples include x86/x86-64 (Intel, AMD) and ARM (mobile devices and many modern laptops).</p> <p>Note</p> <p>An Intel CPU executes x86 instructions, while many smartphone CPUs execute ARM instructions. Programs must be compiled for the correct instruction set so the CPU can run them.</p>"},{"location":"Lecture_Notes/03_hardware/#graphics-processing-unit","title":"Graphics Processing Unit","text":"<p>While the CPU is responsible for general-purpose computation and overall control, modern computers also rely on the Graphics Processing Unit (GPU). A GPU is a specialized processor designed to perform a very large number of simple calculations in parallel. Originally, GPUs were built for graphics workloads such as rendering 3D scenes and updating frames smoothly in games and graphical applications.</p> <p>Unlike the CPU, which has a small number of powerful cores optimized for sequential work, a GPU contains thousands of simpler cores optimized for parallel operations. This makes GPUs efficient at tasks where the same computation must be applied to many data elements at once, such as pixels, vertices, or vectors.</p> <p>Today, GPUs are widely used beyond graphics, including scientific computing, simulations, video processing, and artificial intelligence, where large matrix and vector operations are common. In typical workloads, the CPU manages control flow and coordination, while the GPU performs heavy numerical computation.</p>"},{"location":"Lecture_Notes/03_hardware/#memory-devices","title":"Memory Devices","text":"<p>Every computer must store data and instructions so the CPU can use them. The place where this information is kept is called memory. Different kinds of memory serve different purposes\u2014some are very fast but volatile (temporary), while others are slower but non-volatile (persistent). Volatile memory loses its contents when power is removed; non-volatile memory does not.</p> <p>A common classification is:</p> <ul> <li>Primary storage: volatile storage used directly by the CPU (registers, cache, RAM).</li> <li>Secondary storage: non-volatile persistent storage (SSD, HDD) that must be loaded into primary memory before use.</li> <li>Tertiary storage: non-volatile, much slower storage used for backups and archives, often accessed sequentially (optical discs<sup>1</sup>, magnetic tapes).</li> </ul>"},{"location":"Lecture_Notes/03_hardware/#primary-storage","title":"Primary Storage","text":"<p>RAM (Random Access Memory) is the main working memory. It temporarily stores data and instructions the CPU is currently using. RAM is volatile and has two common types: Dynamic RAM (DRAM) and Static RAM (SRAM).</p> <ul> <li>DRAM stores each bit in a tiny capacitor. Because capacitors leak charge, DRAM must be refreshed continuously. DRAM is cheaper and higher capacity, but slower than SRAM. It serves as the computer\u2019s main memory.</li> <li>SRAM uses flip-flop circuits that keep data stable while power is on, without refreshing. SRAM is faster but larger and more expensive.</li> </ul> <p>Cache memory is a very small, ultra-fast SRAM built into the CPU. It stores frequently used data and instructions so the CPU does not repeatedly fetch them from slower RAM. L1 cache is the smallest and fastest (per core). L2 cache is larger and slower. L3 cache is larger still and often shared across cores.</p> <p>Note</p> <p>Imagine you have several browser tabs open. The content and program state for those tabs are stored in DRAM so the CPU can access them while you work. If power is removed, those in-memory states disappear.</p> <p>At the same time, the CPU uses much smaller but faster SRAM cache for the most frequently used instructions and data. When the same parts of a webpage or video are accessed repeatedly, cache reduces the time spent waiting on DRAM, improving responsiveness.</p> <p>Read-Only Memory (ROM)<sup>3</sup> is non-volatile memory that retains data when power is off. During startup, the CPU reads firmware from ROM\u2014commonly BIOS or UEFI\u2014which checks hardware and then loads the operating system into RAM. ROM is typically programmed by the manufacturer, although modern forms like EEPROM can be updated electronically.</p>"},{"location":"Lecture_Notes/03_hardware/#secondary-storage","title":"Secondary Storage","text":"<p>Storage devices use two main retrieval methods: sequential access and direct (random) access. In sequential access, data is read in order until the desired location is reached. In random access, the device can jump directly to a location.</p> <p>Hard Disk Drive (HDD) stores data on spinning magnetic platters, commonly 5,400\u20137,200 RPM. Data is read and written by a moving head. HDDs provide large capacity at low cost, but are slower due to mechanical movement and more vulnerable to shock. HDDs support random access.</p> <p>Solid State Drive (SSD) stores data in flash memory and has no moving parts, making it much faster and more reliable than HDDs. SSDs offer fast boot times, quick application loading, and low-latency file access. Their cost per gigabyte is typically higher than HDDs.</p> <p>Figure 4. Storage hierarchy pyramid (made with matplotlib).</p> <p>To summarize, the storage hierarchy organizes memory and storage by speed, cost per bit, and capacity. At the top, registers and cache are the fastest but smallest and most expensive per bit. RAM is next: slower than cache, larger, and still volatile. Below RAM, SSDs provide persistent storage with low latency. HDDs provide larger capacity at lower cost but with slower access times. Optical discs and magnetic tape sit lower in the hierarchy: they are cheaper per bit and good for distribution or archival storage, but much slower, especially for random access. Moving upward increases speed and cost per bit while reducing capacity; moving downward increases capacity and lowers cost per bit while increasing access time.</p>"},{"location":"Lecture_Notes/03_hardware/#additional-material","title":"Additional Material","text":"<ul> <li>How do Transistors Build into a CPU? How do Transistors Work?</li> <li>How do Hard Disk Drives Work?</li> <li>How does Computer Memory Work?</li> <li>How Computers Calculate - the ALU: Crash Course Computer Science #5</li> <li>How a CPU Works in 100 Seconds</li> <li>Von Neumann Architecture - Computerphile</li> <li>How do Graphics Cards Work? Exploring GPU Architecture</li> </ul> <ol> <li> <p>Disk is standard in computer science for magnetic and solid-state storage (hard disk, disk drive). Disc is used for optical media (CD/DVD/Blu-ray discs).\u00a0\u21a9</p> </li> <li> <p>ROM is not used as working memory and is best treated separately from primary/secondary/tertiary storage.\u00a0\u21a9</p> </li> <li> <p>ROM is not working memory and is not considered primary memory, because it stores non-volatile firmware used mainly during system startup rather than data and instructions actively processed by the CPU.\u00a0\u21a9</p> </li> </ol>"},{"location":"Lecture_Notes/04_algorithm/","title":"Algorithm & Algorithmic Actions","text":"<p>{% include lecture-styles.html %}</p> <p>{% include lecture-header-info.html %}</p> <p>An algorithm is a step-by-step procedure or set of rules to solve a specific problem or perform a task. It is like a recipe in cooking: you follow a clear sequence of actions to achieve a specific result. In computer science, algorithms receive some input, process it in a logical way, and produce an output. What makes a good algorithm is that it has a clear starting point, a clear ending point, and every step is unambiguous - there is no confusion about how it should be executed.</p>   **_Example._** Imagine you want to find the largest of three numbers: A, B, and C. A simple algorithm would say: first compare A and B. If A is greater than or equal to B, then compare A with C. If A is still the greatest, then A is the largest number. Otherwise, C is the largest. But if in the very first comparison B was already greater than A, then compare B with C, and whichever is larger is the answer. This exact set of steps can be written in code or performed by a person.  **_Exercise._** Bring an example of an algorithm from your daily life.   <p>The word algorithm traces back to the name of the mathematician Al-Khwarizmi, whose systematic approach to calculation and problem-solving became foundational to modern mathematics and computing. Similarly, the word algebra comes from his mathematical treatise Al-Jabr, translated as \"completion\" or \"rejoining\".</p> <p>Turing Award winner computer scientist Donald Knuth is best known for the book The Art of Computer Programming. His work helped establish algorithmic analysis as a discipline.</p> <p>Computational complexity of an algorithm describes how the resources an algorithm needs (e.g. time, memory, etc.) grow as the input size increases. Time complexity tracks how many computational steps are required. Space complexity tracks how much memory is used. Within these, we distinguish worst-case, average-case, and best-case behavior depending on how the input might vary. Asymptotic (Big O) notation provides a language for comparing growth rates when inputs become large. Big O gives an upper bound: it states that the algorithm grows no faster than some function up to constant factors. Big O abstracts away hardware, implementation details, and constants, focusing only on how the algorithm scales with input size.</p> <p> </p> <p>Knuth also wrote a special foreword publication for participants of the International Olympiad in Informatics (IOI 2019) held in Azerbaijan. A Book of Tasty Algorithms is a playful recipe book based on dishes from Azerbaijani cuisine, representing algorithmic ideas through the familiar structure of cooking, drawing a parallel between writing algorithms and following recipes.</p>"},{"location":"Lecture_Notes/04_algorithm/#algorithmic-actions","title":"Algorithmic Actions","text":"<p>Algorithmic actions describe the fundamental operations that make up any computer program. These actions determine how a program makes decisions, repeats steps, organizes tasks, and manages data. The five main algorithmic actions are selection, repetition, modularization, recursion, and name binding.</p> <p>Selection means choosing between different paths of execution based on a condition. It allows the program to \"decide\" what to do depending on input or data values.</p>   **_Example._** If the temperature is above 30 \u00b0C, the system turns on the air conditioner; otherwise, it keeps it off. In programming (pseudo-code):  {% highlight c %}  if (temperature &gt; 30) {  turnOnAC();  } else {  turnOffAC();  } {% endhighlight %}   <p>Repetition means performing the same set of instructions multiple times until a certain condition is met. This prevents code duplication and makes programs efficient.</p>   **_Example._** Printing numbers from 1 to 5 using a loop. In programming (pseudo-code):  {% highlight c %}  for (int i = 1; i &lt;= 5; i++) {  print(i);  }  {% endhighlight %}   <p>Modularization means dividing a complex program into smaller, manageable, and reusable parts, called modules. This improves readability, debugging, and reusability.</p>   **_Example._** A billing program may have:  **calculateTax()**\\- computes tax on a purchase  **printBill()**\\- prints the final receipt  Each module performs one well-defined task, making the program organized and easier to maintain.  <p>At a deeper level, modularization is a principle of system organization, not limited to programming. It refers to the act of decomposing any complex system - software, mechanical, social, or educational - into smaller subsystems that can be developed, understood, or replaced independently.</p> <p>In programming, modularization starts with functions, which perform a single, well-defined task. Related functions can be grouped into classes, which represent objects or abstract entities. Several classes and functions together form a module, typically a single file in a programming language like Python. A package is a collection of related modules organized in a directory (folder) structure, and multiple packages can form a library or framework, representing a higher level of modular organization. At the top level, systems or applications integrate many libraries and frameworks, sometimes developed by entirely different teams or companies.</p> <p>In engineering, a car is designed in modules such as the engine, transmission, and electrical system, each of which can be developed or replaced independently. In education, a curriculum may be modularized into separate courses or subjects, each focusing on a distinct domain of knowledge but contributing to an integrated learning goal. In management, an organization may be divided into departments - finance, marketing, research, operations - each acting as a module with a specific role but coordinated under one structure. In architecture, buildings are designed with modular components such as prefabricated walls or units that can be rearranged or replaced.</p> <p>At even higher levels, modularization can be systemic or societal. Complex infrastructures - transportation networks, communication systems, and governance structures - are modularized into interacting parts so that local failures do not collapse the entire system.</p> <p>Modularization is about complexity management: dividing a whole into parts that are independent in function and cooperative in purpose.</p>   **_Exercise._** _Take a major goal of yours for the next six months and divide it into manageable modules._   <p>Recursion occurs when a function calls itself to solve smaller parts of the same problem. Each recursive step reduces the problem size until it reaches a base case, the simplest situation where the function stops calling itself. Base case is NOT the starting point, it is the STOPPING CONDITION.</p> <p>You can imagine of real-life recursion: tree has branches, branches have their smaller branches, those branches have their own smaller branches, etc. But this recursion may go infinitely and you usually need to stop at some point. That stopping condition is the base case. Let's say, after four-five branching steps a tree will stop growing any branches. With that logic, there is no base case in the case of two mirrors oppositely directed to each other. There is no base can and you will see infinite reflections. Or: infinite recursion.</p> <p>In case of factorial, we know that the factorial of n is the factorial of the previous number multiplied by n. That means: {% highlight c %}</p> <p>factorial(5) = factorial(4) * 5</p> <p>factorial(4) = factorial(3) * 4</p> <p>factorial(3) = factorial(2) * 3</p> <p>factorial(2) = factorial(1) * 2</p> <p>{% endhighlight %}</p> <p>Or, as a general case:</p> <p>factorial(n) = factorial(n-1) * n_</p> <p>We can write the following recursive function:</p>   {% highlight c %}  factorial(n) {  return n * factorial(n - 1);}  {% endhighlight %}  <p>But this pseudo-code has an issue. It is akin to two mirrors looking at each other - it will never stop. It will return the following functions:</p> <p>factorial(1) = factorial(0) * 1_</p> <p>factorial(0) = factorial(-1) * 0_</p> <p>factorial(-1) = factorial(-2) * -1_</p> <p>ad infinitum</p> <p>Not only factorial(-1)_ doesn't make sense, but also you will be in an infinite recursion. To fix it, you need to add a halting (stopping) condition: Base case.</p>   {% highlight c %}  factorial(n) {  if (n == 1 or n == 0) return 1; // base case  else return n * factorial(n - 1); // recursive call  } {% endhighlight %}   <p>So, your code will work in the following way, given that n is a non-negative number (in this case n=4): factorial(4) = factorial(3) * 4 = factorial(2) * 3 * 4 = factorial(1) * 2 * 3 * 4 = 1 * 2 * 3 * 4 = 24._</p>   **_Exercise._** Write a pseudo-code for recursive algorithm to find the sum of natural numbers.  <p>Name binding refers to the process of connecting identifiers (names) to specific objects, values, or memory locations in a program. It defines where and when a variable's name is linked to the data it represents. This action allows the program to store, access, and update information consistently.</p>   **_Example._** When you type:  **70**  Somewhere in the memory an **object** is created. For example in memory cell represented with hexadecimal number 0x21A95BC, bytes will allocated to represent 70 in binary. Then, if you want to reuse that value in the future, you need to **assign** (not equalize) that value to an identifier.  **speed = 70**  the name speed becomes bound to the value 70 stored in memory. If later the value changes (speed = 50), the same name now refers to a different value but the same memory binding.   <p>There are two main types of binding: Static (compile-time): the link between name and value is fixed before execution (e.g., variable types in C or Java (e.g. int speed = 70). Dynamic (run-time): the link occurs while the program is running (e.g., variable reassignment in Python).</p>"},{"location":"Lecture_Notes/04_algorithm/#dijkstras-shortest-path-algorithm-dijkstra-shortest-path","title":"Dijkstra's Shortest Path Algorithm {#dijkstra-shortest-path}","text":"<p>In many information systems, a common task is to search for an item. In some systems, the problem involves navigating networks, such as transportation systems or computer networks, where components are connected by links with different costs, delays, or capacities. In these cases, the goal is not merely to locate an item, but to determine an optimal path through the network.</p> <p>Edsger W. Dijkstra was a Dutch computer scientist and one of the founders of modern computer science. Dijkstra's algorithm is a classic solution that computes the shortest path from a starting node to all other nodes in a weighted graph where all edge weights are non-negative. The algorithm maintains a set of nodes whose minimum distance from the start is already known. At each step, it selects the node with the smallest temporary distance, finalizes its distance, and then updates (relaxes) its neighbors by checking whether passing through this node yields a shorter path.</p> <p></p> <p>Dijkstra's algorithm to find the shortest path between a and b. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.</p> <p>By Ibmua - Work by uploader., Public Domain, https://commons.wikimedia.org/w/index.php?curid=6282617</p> <p>A priority queue is often used to efficiently select the next node with the smallest distance, which allows the algorithm to scale well for large graphs. The algorithm finishes when all nodes have been processed or when the destination node is finalized. The output is both the shortest distance and the actual path taken.</p>"},{"location":"Lecture_Notes/04_algorithm/#additional-material","title":"Additional Material","text":"<ul> <li>Intro to Algorithms: Crash Course Computer Science #13</li> <li>What's an algorithm? - David J. Malan</li> <li>What on Earth is Recursion? - Computerphile</li> <li>Binary, Hanoi and Sierpinski, part 1</li> <li>Dijkstra's Algorithm - Computerphile</li> </ul> <p>{% include lecture-footer.html %}</p>"},{"location":"Lecture_Notes/05_software/","title":"05. Programming &amp; Software","text":"<p>Info</p> <ul> <li>Week: 7</li> <li>Rahida Asadli, Ismayil Shahaliyev</li> <li>Created: Nov 9 2025</li> <li>Updated: Dec 20 2025</li> </ul>"},{"location":"Lecture_Notes/05_software/#programming","title":"Programming","text":"<p>Programming is the process of taking an algorithm and writing it in a language that a computer can understand and execute. This language is called a programming language.</p> <p>A computer does not understand programming languages directly. It only understands machine code: very low-level instructions represented in binary (0s and 1s) that tell the CPU exactly what to do. A programming language is therefore a human-readable abstraction that must be translated into machine code before execution.</p> <p>Every programming language has rules about how things must be written. These rules are called syntax. If syntax rules are violated, the program will not run. Even with correct syntax, a program may still behave incorrectly. This is a matter of semantics, which concerns meaning.</p> <p>Note</p> <p>Example. <code>x = 5 + ;</code> is a syntax error. <code>x = \"Hello\" - 3</code> is syntactically valid but semantically meaningless.</p>"},{"location":"Lecture_Notes/05_software/#compiler-vs-interpreter","title":"Compiler vs Interpreter","text":"<p>A compiler translates the entire source code into machine code or an intermediate representation before execution. The result is usually an executable file or bytecode. Compilation detects many errors early and produces fast-running programs, but requires recompilation after changes and often targets a specific platform.</p> <p>An interpreter translates and executes code instruction by instruction during execution. It produces no separate executable. Interpreted programs are easier to test and modify but usually run more slowly and depend on the interpreter at runtime.</p> <p>Compiled languages are typically used where predictable performance is critical, such as mobile apps and games. Interpreted languages are common in scripting, automation, and rapid prototyping.</p> <p>Important. Many modern interpreted languages use just-in-time compilation, blurring the traditional distinction. The key difference today is when and how translation occurs.</p> <p>Note</p> <p>Example (Oversimplified).</p> <p>Program: <pre><code>print(\"Hello\")\nprint(10 + 5)\n</code></pre></p> <p>Interpreter example: <pre><code>print(\"Hello\")\nprint(10 + 5)\nprint(10 / 0)\nprint(\"This will not run\")\n</code></pre></p> <p>The interpreter executes line by line and stops at the error.</p>"},{"location":"Lecture_Notes/05_software/#evolution-of-programming-languages","title":"Evolution of Programming Languages","text":"<p>Programming languages have evolved to make interaction between humans and computers more natural and productive. Each generation increases the level of abstraction, moving further away from hardware details and closer to human concepts.</p> <p>First generation (Machine language). Programs consist entirely of binary instructions (0s and 1s). These instructions are executed directly by the CPU. While extremely fast, they are almost impossible for humans to read, write, or debug.</p> <p>```text 10110000 00000101 10110001 00000110 00000001</p> <p>Second generation  (Assembly language). Assembly replaces raw binary with symbolic instructions that correspond closely to machine operations. Programs are still hardware-specific and must be translated by an assembler.</p> <p>```text MOV AX, 5 MOV BX, 6 ADD AX, BX</p> <p>Third generation (High-level languages). High-level languages use English-like words, familiar mathematical notation, and structured control flow. They are designed to be readable, portable, and independent of specific hardware. Programs written in these languages are translated using compilers or interpreters, allowing the same source code to run on different machines with little or no modification.</p> <p>```text a = 5 b = 6 sum = a + b print(sum)</p> <p>Fourth generation (Very high-level languages). Very high-level languages aim to minimize the amount of code a programmer must write. Instead of specifying detailed procedures, the programmer describes what result is desired. These languages are often domain-specific and commonly used in databases, reporting, and data analysis.</p> <p>```text SELECT * FROM users WHERE name = 'Codd'</p> <p>Fifth generation (Logic-based languages). Logic-based languages are founded on formal logic rather than step-by-step instructions. The programmer defines facts and rules, and the language engine derives conclusions automatically through inference. Control flow is implicit rather than explicitly programmed.</p> <p>```text  parent(alice, bob). parent(bob, carol).</p> <p>ancestor(X, Y) :- parent(X, Y). ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).</p> <p>Example queries: ```text ?- parent(alice, bob). ?- ancestor(alice, carol). ?- ancestor(X, carol).</p> <p>Post-fifth generation (Generative AI systems). In modern computing, many systems are no longer programmed with explicit rules or logical facts. Instead, they are trained on large datasets using machine learning techniques. These systems learn statistical patterns that allow them to generate text, code, images, or actions in response to user prompts. They do not guarantee logical correctness, but they are effective at handling ambiguity, incomplete information, and complex real-world inputs. This shift represents a new interaction paradigm rather than a traditional new generation of programming languages.</p>"},{"location":"Lecture_Notes/05_software/#software","title":"Software","text":"<p>Software consists of computer programs and related documentation that instruct a computer on how to perform tasks. Software translates human intentions into machine-level operations and enables computers to carry out activities ranging from simple calculations to complex simulations and system control.</p> <p>System software is responsible for managing and operating computer hardware. It provides the foundational environment in which other programs can run and ensures that resources such as memory, processing time, and input/output devices are used efficiently.</p> Type Purpose Examples Operating systems Manage hardware and system resources Windows, macOS, Linux Device drivers Enable communication with hardware devices Printer driver, GPU driver Utility programs Perform maintenance and optimization tasks File manager, disk cleanup, antivirus <p>Note</p> <p>When a computer is powered on, the operating system loads first. It initializes hardware components, loads necessary drivers, and prepares the system so that application programs can be executed.</p> <p>Application software consists of programs designed for end users to perform specific tasks. These include productivity tools, creative software, communication applications, and educational programs.</p> <p>Note</p> <p>A user may write documents in LibreOffice or Microsoft Word (application software) running on Ubuntu or Windows (system software), while device drivers handle communication with hardware such as the graphics card and printer.</p> <p>In addition to their functional role, software systems can be categorized by how they are licensed and distributed. Proprietary software is owned and controlled by a company and typically requires a paid license, offering professional support and regular updates. Open-source software makes its source code publicly available, allowing users to inspect, modify, and redistribute it. Organizations choose between these models based on cost, security requirements, support needs, and technical expertise.</p> <p>Note</p> <p>Exercise. Compare the advantages and disadvantages of proprietary and open-source software.</p>"},{"location":"Lecture_Notes/05_software/#operating-systems","title":"Operating Systems","text":"<p>An operating system (OS) is the core software that manages a computer\u2019s hardware and software resources. It acts as an intermediary between users, applications, and the underlying hardware, translating high-level requests into low-level operations and coordinating all system activity.</p> <p>Note</p> <p>Example. A user edits a document, listens to music, and downloads a file at the same time. The operating system schedules CPU time, allocates memory, and manages input/output so all tasks proceed smoothly without interfering with one another.</p> <p>The kernel is the central component of an operating system. It directly controls the CPU, memory, storage, and devices. Users do not interact with the kernel directly; instead, applications make requests that the kernel validates and executes safely.</p> <p>Note</p> <p>Example. When an application saves a file, it sends a request to the operating system. The kernel checks permissions, allocates disk space, and communicates with the storage device through drivers, ensuring system stability and data integrity.</p> <p>The kernel is also responsible for multitasking. When multiple programs run simultaneously, the kernel rapidly switches the CPU between them, giving each program a small time slice. This creates the illusion that all programs are running at the same time.</p> <p>An operating system includes more than just the kernel. It also contains system libraries, background services, device drivers, and user interfaces. Different operating systems can be built around the same kernel. For example, Ubuntu and Android both use the Linux kernel but provide very different environments and user experiences.</p>"},{"location":"Lecture_Notes/05_software/#additional-material","title":"Additional Material","text":"<ul> <li>https://www.youtube.com/embed/l26oaHV7D40</li> <li>https://www.youtube.com/embed/_C5AHaS1mOA</li> <li>https://www.youtube.com/embed/CFRhGnuXG-4</li> <li>https://www.youtube.com/watch?v=26QPDBe-NB8</li> <li>https://www.youtube.com/watch?v=H2tuKiiznsY</li> <li>https://www.youtube.com/watch?v=PK_yguLapgA</li> <li>https://www.youtube.com/watch?v=niWpfRyvs2U</li> </ul>"},{"location":"Lecture_Notes/06_network/","title":"06. Telecommunications and Computer Networks","text":"<p>Info</p> <ul> <li>Rahida Asadli, Ismayil Shahaliyev</li> <li>Nov 23 2025 / Dec 21 2025</li> </ul>"},{"location":"Lecture_Notes/06_network/#telecommunications","title":"Telecommunications","text":"<p>Telecommunications is the long-distance transmission of information using electronic or electromagnetic signals. Whenever two devices exchange information (a voice call, a video stream, a bank transaction), telecommunications is operating in the background. Telecommunications makes communication possible without physical proximity. A phone call between countries, a campus network connecting buildings, or a satellite sending weather data to Earth are all telecommunications in action.</p> <p>Every telecommunication system follows the same basic structure: sender \u2192 channel (medium) \u2192 receiver. The sender is where information originates. The channel is the path between sender and receiver, such as copper cable, fiber-optic cable, or wireless radio waves. The receiver converts the incoming signal back into a usable form. For communication to work, both sides follow shared rules called protocols, which define how data is formatted, transmitted, and interpreted.</p>"},{"location":"Lecture_Notes/06_network/#glossary","title":"Glossary","text":"<p>Before starting, it helps to know core terms that appear frequently in telecommunications and networks.</p> <p>Attenuation is the weakening of a signal as it travels through a medium. The longer the distance, the weaker the signal becomes. Copper cables usually attenuate faster than fiber. When attenuation becomes too high, the receiver may get a distorted or unreadable signal, which is why long links may require repeaters or amplifiers.</p> <p>Electromagnetic interference (EMI) is the disturbance caused by external electrical or magnetic sources. Power lines, motors, and electronic devices can disrupt electrical signals in copper cables. Fiber uses light, so it is not affected by EMI.</p> <p>Bandwidth is the maximum amount of data that a medium or network can carry per second. It is capacity, not \u201cspeed of electricity.\u201d Bandwidth is usually measured in Mbps or Gbps.</p> <p>Note</p> <p>A 100 Mbps connection can carry more data per second than a 10 Mbps connection, so large files download faster. Twisted-pair cables support lower bandwidth over short distances compared to coaxial, and fiber typically supports much higher bandwidth over much longer distances.</p> <p>Throughput is the actual amount of data successfully delivered per second. Throughput is usually lower than bandwidth because of interference, distance, congestion, and hardware limits.</p> <p>Note</p> <p>A Wi-Fi link may have a 300 Mbps bandwidth rating, but real throughput might be 80 Mbps due to walls, competing networks, and device limitations. Complaints about \u201cslow internet\u201d are usually complaints about throughput.</p> <p>Signal type refers to the physical form of transmitted data. Twisted-pair and coaxial carry electrical signals. Fiber carries optical signals (light). This is a major reason fiber performs better over distance and resists interference, but it is typically more expensive and harder to install.</p> Property Twisted pair Coaxial cable Fiber-optic cable Cost Low Medium (\u22482\u20133\u00d7 twisted pair) High Installation Easy Easy Difficult Attenuation High Moderate Very low Signal type Electrical Electrical Optical (light) Bandwidth ~1\u2013100 Mbps Hundreds of Mbps to Gbps Gbps to Tbps Distance ~100 m ~100 m Kilometers EMI effect High Low None <p>Latency is the time it takes for data to travel from one point to another. Even with high bandwidth, high latency can make communication feel slow. Local networks usually have low latency. Long-distance communication often has higher latency.</p> <p>Exercise. Determine the bandwidth and throughput of your device\u2019s current connection.</p>"},{"location":"Lecture_Notes/06_network/#direction","title":"Direction","text":"<p>Communication systems can be classified by how data flows between sender and receiver.</p> <p>Simplex is one-way communication. The receiver cannot respond over the same channel. Television broadcasting is a classic example.</p> <p>Half-duplex is two-way communication, but not at the same time. Devices take turns sending and receiving. Walkie-talkies are a typical example.</p> <p>Full-duplex is simultaneous two-way communication. Phone calls and modern network links are full-duplex, enabling smooth interaction.</p>"},{"location":"Lecture_Notes/06_network/#time","title":"Time","text":"<p>Communication systems can also be classified by timing.</p> <p>Synchronous communication requires both endpoints to be active at the same time and exchange data immediately. It is used when results must be immediate, such as live calls, real-time control, or interactive request-response systems.</p> <p>Asynchronous communication removes time coupling. The sender does not block waiting for the receiver. Messages may be buffered, queued, or stored and processed later. This improves scalability and fault tolerance and is used heavily in modern systems (email delivery, job queues, background processing, batch workflows).</p>"},{"location":"Lecture_Notes/06_network/#range","title":"Range","text":"<p>Distance shapes the technologies and infrastructure used.</p> <p>Personal Area Network (PAN) covers a few meters around a person, connecting devices such as phones, smartwatches, and earbuds.</p> <p>Local Area Network (LAN) covers a home, office, building, or campus network segment. LANs use Ethernet, Wi-Fi, switches, and routers.</p> <p>Note</p> <p>A home network is a LAN: the router connects phones, laptops, and TVs and provides shared access to the internet. A university lab network is also a LAN.</p> <p>Metropolitan Area Network (MAN) spans a larger area, typically a city or a large multi-building campus.</p> <p>Wide Area Network (WAN) covers very large areas such as countries or continents. WANs rely on backbone networks, long-haul fiber, satellites, and high-capacity routers.</p> <p>Note</p> <p>The Internet is the most significant WAN. International banking and airline reservation systems also run over WAN-scale connectivity.</p>"},{"location":"Lecture_Notes/06_network/#computer-networks","title":"Computer Networks","text":"<p>A computer network is a collection of devices connected so they can exchange data. Devices communicate by sending information over cables or wireless signals. To do this, networks rely on hardware, addressing, and agreed rules.</p>"},{"location":"Lecture_Notes/06_network/#glossary_1","title":"Glossary","text":"<p>MAC (Media Access Control) address is a hardware-based identifier for a network interface, typically shown as 12 hexadecimal digits such as <code>00:1A:2B:3C:4D:5E</code>. It identifies devices within a local network segment.</p> <p>IP (Internet Protocol) address is a logical address used for communication across networks. Unlike MAC addresses, IP addresses can change depending on the network.</p> <p>Hub connects multiple devices but does not direct traffic intelligently. It repeats incoming data to all ports, creating unnecessary traffic.</p> <p>Switch forwards data intelligently inside a local network. It learns MAC addresses and sends frames only to the intended device.</p> <p>Router connects different networks and forwards packets based on IP addresses. A home router connects a LAN to the ISP and then to the Internet.</p> <p>Modem connects a local network to the ISP\u2019s physical infrastructure. It converts digital data into a signal suitable for the medium and converts incoming signals back into digital data. Many home devices combine modem + router + switch, but these are logically different roles.</p> <p>Frame is the data unit used inside a local network (switching). Frames carry MAC addresses.</p> <p>Packet is the data unit used across networks (routing). Packets carry IP addresses.</p> <p>Packet switching breaks data into packets and routes them independently. This allows many users to share the same links efficiently, supports alternative routes when failures occur, and retransmits only lost packets instead of entire messages.</p> <p>Port is a logical endpoint used by applications to separate different types of communication on the same device. For example, web traffic commonly uses port 80 (HTTP) or 443 (HTTPS).</p> <p>Exercise. Determine the IP and MAC addresses of your device.</p>"},{"location":"Lecture_Notes/06_network/#network-topologies","title":"Network Topologies","text":"<p>Network topology describes the physical or logical arrangement of devices and connections. The topology affects reliability, performance, cost, and how failures spread.</p>"},{"location":"Lecture_Notes/06_network/#bus-topology","title":"Bus Topology","text":"<p>All devices share a single main cable. If the main cable fails, the entire network fails. As more devices communicate, collisions and congestion increase.</p> <p>Note</p> <p>Early office networks used one coaxial cable as a shared backbone. Damage to that cable could stop all communication.</p> <p></p>"},{"location":"Lecture_Notes/06_network/#star-topology","title":"Star Topology","text":"<p>All devices connect to a central device (usually a switch). If one cable fails, only that device is affected. If the central device fails, the whole network stops.</p> <p>Note</p> <p>Modern home and office networks usually follow star topology: devices connect to a central router or switch.</p> <p></p>"},{"location":"Lecture_Notes/06_network/#ring-topology","title":"Ring Topology","text":"<p>Devices form a loop. Data travels around the ring until it reaches the destination. A single break can disrupt the loop unless rerouting exists.</p> <p>Note</p> <p>Some older campus and metropolitan networks used ring designs to connect buildings in a loop.</p>"},{"location":"Lecture_Notes/06_network/#mesh-topology","title":"Mesh Topology","text":"<p>Devices connect through multiple redundant paths. If one link fails, traffic can reroute through others. This is reliable but expensive and complex.</p> <p>Note</p> <p>Internet backbone providers use mesh-style redundancy so failures do not interrupt global connectivity.</p> <p></p> Topology Advantages Disadvantages Bus Simple and cheap for small networks; less cable Backbone failure stops everything; performance drops as devices increase; hard to troubleshoot Star Easy to manage; single device failure usually isolated; easy to add/remove devices; strong performance Central switch/router failure stops the network; more cable required Ring Predictable data flow; no collisions in token-based rings; equal access One failure can disrupt the loop; harder to reconfigure Mesh High reliability; multiple paths; strong fault tolerance Expensive; complex installation and maintenance Line Simple linear structure; easy to extend at ends Middle failure breaks downstream communication; limited scalability Tree Easy to expand; common in large networks Backbone failure affects branches; more cable; more complex configuration"},{"location":"Lecture_Notes/06_network/#additional-material","title":"Additional Material","text":"<ul> <li>Computer Networks: Crash Course Computer Science #28</li> <li>MAC address explained</li> <li>Hub, Switch, &amp; Router Explained - What's the difference?</li> <li>Network Topologies (Star, Bus, Ring, Mesh, Ad hoc, Infrastructure, &amp; Wireless Mesh Topology)</li> <li>Network Ports Explained</li> <li>What is Ethernet?</li> </ul>"},{"location":"Lecture_Notes/07_internet/","title":"07-08. The Internet and the World Wide Web","text":"<p>Info</p> <ul> <li>Nilufar Ismayilova, Rumiyya Alili, Ismayil Shahaliyev</li> <li>Nov 21 2025 / Dec 23 2025</li> </ul>"},{"location":"Lecture_Notes/07_internet/#the-internet","title":"The Internet","text":"<p>The Internet is a global network of interconnected computer networks that allows devices around the world to communicate. It is not controlled by any single organization; instead, many independent networks\u2014such as home networks, university networks, company networks, and government networks\u2014connect to each other voluntarily. Together, these connections form a large, decentralized system that enables information to travel quickly and reliably between distant points.</p> <p>For communication to be possible across such a system, all connected devices must follow common rules. These rules are called network protocols. A protocol defines how data is sent, in what format, in what order, and what happens if errors occur. Without protocols, networks could be physically connected, but devices would not understand each other.</p> <p>The Internet follows a hierarchical structure. Local networks connect to Internet Service Providers (ISPs), which then connect to larger regional networks and finally to high-speed backbone networks that carry data across countries and continents. When you open a website or send a message, your data travels through this chain of networks according to agreed-upon protocols until it reaches its destination.</p>"},{"location":"Lecture_Notes/07_internet/#internet-protocol-suite","title":"Internet Protocol Suite","text":"<p>The Internet Protocol Suite, commonly known as TCP/IP, is the foundational set of communication rules that defines how data is prepared, addressed, transmitted, and received across the Internet. It organizes network communication into layers, where each layer performs a specific part of the process.</p> <p>At the core is the Internet Protocol (IP), which assigns addresses to devices and routes data packets from the sender to the correct destination, even if they pass through many different networks. Above IP, the suite includes transport protocols that manage how data is broken into smaller pieces, how those pieces travel, and how they are reassembled when they reach the receiver.</p> <p>TCP (Transmission Control Protocol) and UDP (User Datagram Protocol) are the two main transport protocols. TCP provides reliable, ordered, error-checked delivery. It establishes a connection, confirms delivery, and retransmits lost packets. TCP is used when accuracy matters, such as loading websites, sending emails, or downloading files. UDP is faster but does not provide guaranteed delivery or ordering. Lost packets are not retransmitted. UDP is used for real-time applications where speed matters more than perfect accuracy, such as video calls, online gaming, and live streaming.</p> <p>Note</p> <p>When you visit a website, your request is divided into packets and routed across multiple networks to the server\u2019s IP address. Because web traffic uses TCP, packets are delivered reliably and reassembled in order. In a video call, UDP may be used instead to avoid delays caused by retransmissions.</p>"},{"location":"Lecture_Notes/07_internet/#ip-address","title":"IP Address","text":"<p>IP addressing uniquely identifies devices on a network so routers know where to deliver packets. An IP address functions like a postal address: it identifies the destination and the sender.</p> <p>IPv4 uses 32 bits, written as four decimal numbers separated by dots, such as <code>192.168.1.4</code>. IPv6 uses 128 bits, written as hexadecimal blocks separated by colons, such as <code>2001:db8:85a3::8a2e:370:7334</code>. IPv6 was introduced because the IPv4 address space is too small for the number of modern devices.</p> <p>Exercise. How many unique addresses are possible with IPv4? What about IPv6?</p>"},{"location":"Lecture_Notes/07_internet/#domain-name-system","title":"Domain Name System","text":"<p>The Domain Name System (DNS) translates human-readable domain names into IP addresses. Without DNS, users would have to memorize numerical IP addresses for websites.</p> <p>DNS is hierarchical. At the top is the root domain (<code>.</code>), usually hidden. Under it are top-level domains (TLDs) such as <code>.com</code>, <code>.az</code>, <code>.org</code>. Under each TLD are second-level domains such as <code>edu.az</code>. Subdomains further divide these, such as <code>ada.edu.az</code> or <code>library.ada.edu.az</code>.</p> <p>Note</p> <p>When you type <code>www.ada.edu.az</code>, your computer asks DNS for the IP address. DNS returns the IP, and the browser connects to that server. This lookup happens automatically in the background.</p>"},{"location":"Lecture_Notes/07_internet/#routing","title":"Routing","text":"<p>Routing is the process by which routers determine paths for data packets to travel across networks from source to destination. Internet traffic usually passes through multiple routers, and each router decides where to send the packet next.</p> <p>Static routing is configured manually. It is predictable and simple but does not adapt if a link fails.</p> <p>Default routing sends any unknown destination to a single next-hop router. Home networks often use default routing to send all external traffic to the ISP.</p> <p>Dynamic routing uses protocols that let routers exchange information and update routes automatically based on network conditions. This is essential for large networks and the Internet backbone.</p> <p>Note</p> <p>If one route becomes congested or unavailable, dynamic routing helps traffic flow through alternative paths automatically.</p>"},{"location":"Lecture_Notes/07_internet/#osi-model","title":"OSI Model","text":"<p>The OSI (Open Systems Interconnection) model explains networking using seven layers. Each layer has a specific role and interacts with the layer above and below it.</p> # Layer Function Example 7 Application Services used by applications; protocols like HTTP, DNS, FTP, SMTP Browser uses HTTP to request a webpage; DNS resolves a domain name 6 Presentation Data format translation, compression, encryption/decryption (TLS/SSL) HTTPS encrypts data so attackers cannot read passwords 5 Session Establishes and manages communication sessions A video call maintains a session so streams stay coordinated 4 Transport End-to-end delivery; TCP reliability, UDP low overhead Web pages use TCP; games often use UDP 3 Network Routing between networks; IP addressing Routers forward packets using destination IP addresses 2 Data Link Local delivery; framing; MAC addresses; link-level error detection Wi-Fi/Ethernet frames addressed to the local router\u2019s MAC 1 Physical Transmits raw bits via signals over cable, fiber, or radio Wi-Fi radio waves; Ethernet electrical pulses <p>Note</p> <p>When you open a website, the browser starts at the Application layer (HTTP). If it is HTTPS, encryption is applied. TCP carries the request reliably. IP routes it across networks. Wi-Fi/Ethernet handles local delivery, and the physical medium transmits signals.</p>"},{"location":"Lecture_Notes/07_internet/#world-wide-web","title":"World Wide Web","text":"<p>The World Wide Web is a global information system of web pages and services accessed through browsers. The Internet is the network infrastructure; the Web is one service that runs on it. Web pages are connected through hyperlinks and are typically written in HTML. Browsers request resources from web servers and render them for users.</p> <p>Hypertext Transfer Protocol (HTTP) defines how browsers request resources and how servers respond. Servers return status codes such as <code>200 OK</code> or <code>404 Not Found</code>.</p> <p>Most modern sites use HTTPS, which is HTTP plus encryption using TLS. This protects sensitive data (passwords, payments, personal information) from interception and modification.</p> <p>Note</p> <p>When you sign in to a website, HTTPS encrypts your credentials so someone on the same Wi-Fi network cannot read them.</p> <p>A Uniform Resource Locator (URL) is the full address of a web resource. It includes the protocol, domain, path, and optional query parameters.</p> <ul> <li><code>https</code> is the protocol  </li> <li><code>www.ada.edu.az</code> is the domain name  </li> <li><code>/en/search</code> is the path  </li> <li><code>?query=SITE</code> is a query parameter  </li> </ul>"},{"location":"Lecture_Notes/07_internet/#markup-languages","title":"Markup Languages","text":"<p>Markup languages annotate text so computers can understand structure and presentation.</p> <p>HTML structures web pages using tags such as <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and <code>&lt;img&gt;</code>.</p> <p>XML stores and transports structured data using custom tags, often for configuration and interoperability.</p> <p>JSON is a lightweight data format using key-value pairs. It is widely used in APIs and web applications because it is simple and efficient.</p> <p>Note</p> <p>A website uses HTML for what the browser displays. A web application often uses JSON behind the scenes to exchange data between the frontend and backend.</p>"},{"location":"Lecture_Notes/07_internet/#intranet-and-extranet","title":"Intranet and Extranet","text":"<p>An intranet is a private network used inside an organization. It provides internal services such as employee portals, shared files, calendars, and internal communication.</p> <p>An extranet extends an intranet by granting limited access to external users such as partners, suppliers, contractors, or students. Access is controlled through accounts, permissions, or VPN.</p> <p>Note</p> <p>A company intranet may host internal HR and financial documents. An extranet may allow a contractor to access only a shared project folder and schedule, not the full internal system.</p>"},{"location":"Lecture_Notes/07_internet/#cloud-computing","title":"Cloud Computing","text":"<p>Cloud computing delivers computing resources\u2014servers, storage, databases, networking, and software\u2014over the Internet. Instead of buying and maintaining hardware, organizations rent resources on demand. This enables scalability, flexibility, and pay-as-you-go cost models.</p> <p>Cloud services are often grouped into three models:</p> <ul> <li>Infrastructure as a Service (IaaS): virtual machines, storage, networking</li> <li>Platform as a Service (PaaS): managed platforms for building and deploying apps</li> <li>Software as a Service (SaaS): ready-to-use applications delivered via browser</li> </ul> <p>Note</p> <p>Email services, online storage, and learning platforms are common SaaS examples. Renting virtual machines to host a website is an IaaS example.</p>"},{"location":"Lecture_Notes/07_internet/#centralized-decentralized-distributed-systems-centralized","title":"Centralized, Decentralized, Distributed Systems {#centralized}","text":"<p>A centralized system relies on a single central authority or server. It is simpler to manage but fragile: if the central point fails, the whole system may stop.</p> <p>A decentralized system has multiple independent authoritative nodes. If one node fails, others can continue operating. The Internet is decentralized at the network level.</p> <p>A distributed system splits computation and storage across many nodes that coordinate to function as one system. Distributed systems emphasize scalability, performance, and fault tolerance.</p> <p></p> <p>In short, centralized means one control point, decentralized means multiple independent control points, and distributed means many coordinated components working together. These concepts overlap in practice but describe different design trade-offs.</p>"},{"location":"Lecture_Notes/07_internet/#additional-material","title":"Additional Material","text":"<ul> <li>What is Internet?</li> <li>The Internet: Crash Course Computer Science #29</li> <li>Public vs Private IP Address</li> <li>How a DNS Server (Domain Name System) works</li> <li>TCP vs UDP Comparison</li> <li>Network Layers Model (Networking Basics) - Computerphile</li> <li>VPN (Virtual Private Network) Explained</li> <li>The World Wide Web: Crash Course Computer Science #30</li> <li>What is the world wide web? - Twila Camp</li> <li>How trees secretly talk to each other - BBC World Service</li> <li>SSL, TLS, HTTP, HTTPS Explained</li> <li>HTTP Crash Course &amp; Exploration</li> <li>HTTP 1 vs HTTP 2 vs HTTP 3!</li> <li>DHCP Explained - Dynamic Host Configuration Protocol</li> <li>Cloud Computing Explained</li> <li>How to Setup VS Code for Web Development (2025) HTML, CSS, JavaScript + Live Server</li> <li>Every File Format Explained in 16 Minutes</li> </ul>"},{"location":"Lecture_Notes/09_database/","title":"Databases & Database Management Systems","text":"<p>{% include lecture-styles.html %}</p> <p>{% include lecture-header-info.html %}</p> <p>In the past, many systems stored information in simple text files. For example, a file named students.txt could have lines like:</p>   1201, R\u0259fail, IT, 3.5  1202, Nadal, CS, 3.9  <p>Each line is one student. To use this information in a program, the programmer has to open the file, read each line, and split it into parts (ID, name, major, GPA). That \"splitting into parts\" is what we call parsing: taking one long string like \"1201, R\u0259fail, IT, 3.5\" and turning it into separate values: 1201, R\u0259fail, IT , and 3.5.</p> <p>If the university also has courses, grades, payments, dorms, and so on, there may be many different text files: students.txt , courses.txt , grades.txt, etc. Every application (mobile app, website, internal admin tool) must know how each file is structured and must write its own code to read, search, and update those files.</p> <p>This creates several problems (Exercise. Which problems?):</p> <ul> <li>If a value changes (for example, a department name), it may appear in many files. Someone has to open every file and change it everywhere. It is very easy to miss one place and end up with inconsistent data.</li> <li>To find something, the program usually has to read the whole file line by line, which becomes slow as the file grows.</li> <li>If two users or two programs try to edit the same file at the same time, the file can become corrupted, because there is nothing to coordinate their changes.</li> <li>If the computer crashes in the middle of writing to a file, part of the data might be lost or left in a broken state.</li> </ul> <p>To solve these problems, we use the database approach.</p>"},{"location":"Lecture_Notes/09_database/#database-approach","title":"Database Approach","text":"<p>Database is an organized collection of data, and a Database Management System (DBMS) is the software that manages this data for us. You can think of the DBMS as a very smart program whose only job is to store, protect, and provide access to data in a safe and efficient way.</p> <p>Instead of many separate text files, the DBMS may store data in tables with rows and columns. You describe to the DBMS what kind of data you want to store (for example: a table Students with columns StudentID, Name, Major, GPA), and then the DBMS takes care of: Storing the data on disk in an efficient way. Checking rules, such as \"every student must have a unique ID\". Allowing many users/programs to read and update the data at the same time without corrupting it. Recovering from crashes so your data is not lost.</p> <p>The big advantage is that applications no longer need to worry about reading raw files or parsing lines manually. They simply ask the DBMS: \"Give me all students from the IT major with GPA above 3.0\", and the DBMS finds and returns the result.</p> <p>Because the DBMS hides all the low-level details of how data is stored on disk, we can change the physical storage (for example, move to a faster disk, change indexes) without changing the applications that use the data. Applications only see the logical structure (tables and columns) while the DBMS handles the physical (e.g. hardware-level) interaction.</p> <p>In short: The traditional file-based approach = many text files + lots of custom code + high risk of inconsistency and corruption. The database approach = one central DBMS (just software) that stores data in tables, enforces rules, supports many users, and provides a simple and safe way to work with data.</p> <p>Database Indexing Example. Suppose a database table contains 10,000 records, each identified by a unique numeric ID, and an index exists on this ID column. A query asks for the record with ID 7421. Without an index, the database would need to scan the table sequentially, potentially examining all 10,000 rows. With the index, the database starts near the middle of the index and compares against a value such as 5000. Since 7421 &gt; 5000, it ignores the lower half. It then compares against 7500, then 7000, and continues narrowing the range. After only a small number of comparisons, the exact index entry is found, and the database follows its pointer directly to the correct row.</p> <p>When a database table contains thousands or millions of records, searching for specific information can become very slow if the system has to read every single row. This is where database indexing becomes essential. A database index is a data structure that improves the speed of data retrieval operations on a database table. Think of it like the index at the back of a textbook: instead of reading every page to find information about Napoleon, you look up \"Napoleon\" in the index, which tells you exactly which pages to read. Similarly, a database index allows the system to quickly locate data without scanning every row.</p> <p>When you create an index on a table, the database manager requires you to specify an index key field, the column on which the index will be based. For example, if you frequently search for students by their Student ID, you would create an index on the Student ID column. The database then performs these steps:</p> <ul> <li>Reading and Extracting. The DBMS reads each record in the table and extracts the value from the key field along with a pointer that indicates where that record is physically stored.</li> <li>Sorting. All extracted values are sorted in alphanumeric order. This sorted list becomes the index.</li> <li>Creating a Search Structure. The index is typically organized as a tree structure. This allows the database to search very efficiently. Instead of checking every entry, it uses a divide and conquer approach: it starts at the top of the tree and narrows down the search by following branches, similar to how you would search for a word in a dictionary by opening it roughly in the middle and then deciding whether to look in the first half or second half.</li> </ul> <p>By Mazen Embaby - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=124018514</p> <p>In practice, databases do not rely on the simple binary search described in the example above. Instead, they use structures such as B-trees (or B+ trees) which generalize the same divide-and-conquer principle while being optimized for disk access and large datasets.</p> <p>While indexes dramatically speed up searches, they come with costs. Indexes require additional disk space to store the sorted key values and pointers. When you insert, update, or delete records, the index must also be updated, which takes extra time. Indexes need to be maintained and occasionally rebuilt as the database grows. For this reason, indexes are typically created on columns that are frequently used in search queries or for sorting, such as student IDs, email addresses, or dates.</p>"},{"location":"Lecture_Notes/09_database/#data-models","title":"Data Models","text":"<p>A database is never built \"in the abstract\". Database always models something that exists in the real world. It means that every important object and every important interaction in those processes should be representable as data in the database.</p> <p>Entity-Relationship (ER) diagram is a graphical representation of the data model. ER diagram uses a small set of visual symbols to represent the structure of data. Each symbol corresponds to a key concept: entities, attributes, and relationships. ER diagram is the blueprint from which the entire database schema is built.</p> <p>Entity is something that exists independently and can be uniquely identified. It is an abstraction that captures one distinguishable concept in the real world. The important point is that each entity must be capable of having data stored about it, and it can be uniquely distinguished from all other entities. Entities behave like nouns in language. Examples: Employee, Computer, Song, Book, Department.</p> <p>Attributes describe the properties of an entity. For example, Student entity may have attributes: Name, Surname, GPA, Admission Year. Some attributes have special roles like, primary key attributes, uniquely identifying each instance.</p> <p>Relationship shows how two or more entities are connected. Relationships behave like verbs linking nouns (entities). For example, Employee works in Department, Artist performs Song.</p> <p>Each relationship has a cardinality (1:1, 1:N, or M:N) that determines how the relationship will appear in the database schema. For example, one employee works in one department (1:1), one department has many employees (1:N), a student takes many courses and a course has many students (M:N).</p> <p>A data model can be the collection of all these entities, their attributes, and their relationships. These constraints determine how tables will be constructed in the relational model. This data model is more than just storage: if the business rule says \"a student cannot enroll in the same course twice in the same semester\", that rule should be reflected in the model.</p>   **_Exercise._** Provide an example of good and bad data models."},{"location":"Lecture_Notes/09_database/#relational-database-model","title":"Relational Database Model","text":"<p>Relational database model is the most widely used way of organizing data today. In the relational model, all information is stored in tables, similar to spreadsheets. Each table has rows, where each row represents one item (for example, one student), and columns, where each column represents something we want to store about that item (such as the student's name or GPA). Every table must have a special column called a primary key, which uniquely identifies each row. This prevents duplicate data and helps the database keep everything organized. When one table needs to refer to a row in another table, it stores the primary key of that row. This stored value is called a foreign key, and it creates a link between tables.</p>   **_Exercise 1._** How can an ER diagram be represented with relational database model?  **_Exercise 2._** Take two tables and provide examples for primary and [foreign keys](https://en.wikipedia.org/wiki/Foreign_key).  <p>Before relational databases existed, computers used different models to store data. One of these early models was the hierarchical model, which stored data in a tree-like structure. Imagine a company: at the top is the company itself, underneath are departments, and underneath each department are employees. Data could only be accessed by following this fixed path. This made the system rigid: if a programmer wanted to view employees grouped in a different way - for example, sorted by project instead of department - it became a challenging task. Changing the structure of the tree often broke the programs that depended on it.</p>"},{"location":"Lecture_Notes/09_database/#structured-query-language-sql-sql","title":"Structured Query Language (SQL) {#sql}","text":"<p>When comparing different data modeling options, the relational model remains dominant because it provides a balanced combination of structure, accuracy, and flexibility. Its clear table format makes the data easy to understand. Its rules, like primary keys and foreign keys, help prevent mistakes. And because relational databases were designed to be independent of physical storage, programs do not break when the database engine changes how it stores data internally. SQL makes querying relational data straightforward and powerful. For these reasons, relational databases are used in banks, universities, hospitals, e-commerce websites, government systems, and almost every field where consistent and reliable data is essential.</p> <p>SQL is a simple query language used to communicate with the relational database. The name comes from its original form, SEQUEL (Structured English Query Language), which was developed at IBM in the 1970s. The language was designed to work with the relational model proposed by Edgar F. Codd, whose work showed that data could be represented and queried using mathematical relations rather than low-level file structures. The name was later shortened to SQL for trademark reasons, but the pronunciation \"sequel\" remained common.</p> <p>Strictly speaking, SQL is not a single language, but a family of languages defined by international standards. Organizations such as ANSI and ISO publish SQL standards that specify core syntax and behavior. However, real database systems do not implement the standard exactly. Instead, each DBMS provides its own SQL dialect, extending or modifying the standard. Common SQL implementations include Oracle, MySQL, PostgreSQL, Microsoft SQL Server, and SQLite. While these systems share a large common subset of SQL, they differ in features, syntax extensions, and behavior.<sup>1</sup></p> <p>Instead of describing how data should be accessed, SQL allows users to specify what data they want, and the database system determines the most efficient way to retrieve it. The following query will retrieve two columns from the table students.</p> <p>SELECT id, name FROM students</p> <p>A new row to the table can be added with the following query:</p> <p>INSERT INTO students (id, name, gpa) VALUES (1203, 'Badambura', 2.0)</p> <p>Or deletion can be achieved based on a certain condition:</p> <p>DELETE FROM students WHERE id=1203</p>"},{"location":"Lecture_Notes/09_database/#database-normalization","title":"Database Normalization","text":"<p>Because SQL works directly with table names and column names, the structure of the data model becomes extremely important. SQL queries depend completely on how the data model is designed. A bad data model may allow duplication of information, contradictions, and anomalies when inserting, updating, or deleting data. To avoid bad data modeling, Edgar F. Codd and his colleagues at IBM developed a whole theory, known as normalization.</p> <p>Normalization gives us formal rules for structuring tables so that each fact is stored only once, dependencies are clear, and common update problems are avoided. Normalization helps ensure the schema is correct before SQL is written. A normalized schema reduces repeated data, avoids confusing table designs, keeps SQL queries stable for many years and makes it easier to maintain and extend the system. In practice, when you design databases in your professional career, you will rely on these normalization rules to evaluate and refine your schemas.</p> <p>Exercise. It is highly suggested for you to take at least a brief look at different normal forms, starting from the first normal form (1NF).</p> <p>A bad data model becomes a long-term problem. It forces teams to constantly rewrite SQL queries, fix broken reports, and update multiple systems when the structure changes. A good data model, built with normalization in mind, protects the entire system. It keeps SQL programs reliable, keeps data consistent, and makes the database easier to manage as the organization grows. This is why investing time in designing the data model properly at the beginning is one of the most important steps in database development.</p>"},{"location":"Lecture_Notes/09_database/#data-manipulation","title":"Data Manipulation","text":"<p>Relational algebra is the mathematical foundation of how relational databases operate. Although we eventually write SQL queries and may not write algebra expressions directly, SQL is built on top of these relational algebra ideas (Edgar F. Codd was a mathematician in the end. Check out his infamous paper). The three most important operations in relational algebra are selection, projection and the idea of join. These operations describe how we retrieve information from tables, how we combine tables.</p> <p>Selection is the operation that chooses certain rows from a table based on a condition. For example, if we have a students table and want to find only the students from SITE, the database can perform a selection. In algebra, this is written as . In SQL, the same idea appears in the WHERE clause:</p> <pre><code>SELECT * FROM students WHERE school = 'SITE'\n</code></pre> <p>Selection does not change the columns of the table (not to confuse it with the SELECT keyword!). It only filters out the rows that do not match the rule. This operation corresponds to everyday questions such as \"Which employees work in the Finance department?\" or \"Which orders were created today?\"</p> <p>Projection is the operation that chooses certain columns from a table and ignores the others. If we take the Students table and want only the name and gpa, projection removes the unnecessary columns. Similar to selection's , in relational algebra, projection is denoted by the Greek letter \u03c0. In SQL, this appears in the SELECT keyword:</p> <pre><code>SELECT name, gpa FROM students;\n</code></pre> <p>Projection helps keep results focused and avoids returning more data than necessary. It supports questions like \"Show me only the names of students,\" \"List only the prices of products,\" or \"Give me the course codes without any other details.\"</p> <p>Joining is one of the most important relational algebra operations because it allows us to combine information stored in different tables. Since relational databases split data into multiple simple tables, joining them back together is essential for answering real questions. For example, suppose we have a students table and a separate enrollments table. If we want to know which students are taking a particular course, the database joins the two tables by matching rows that share the same student_id. In relational algebra, this is expressed using the join operator \u22c8 together with a join condition. In SQL, the equivalent is a JOIN statement:</p> <pre><code>SELECT students.name, enrollments.course_id FROM students JOIN enrollments USING (student_id);\n</code></pre> <p>Joining allows us to answer questions that cannot be answered using a single table alone, such as \"Which students are in this course?\", \"Which customer placed this order?\", or \"What flights does this passenger have reservations for?\"</p>"},{"location":"Lecture_Notes/09_database/#sql-rdbms-vs-nosql-nrdbms","title":"SQL (RDBMS) vs NoSQL (NRDBMS)","text":"<p>When choosing how to store data, modern systems usually rely on two major families of databases: SQL databases, also called relational database management systems (RDBMS), and NoSQL databases, also called non-relational database management systems (NRDBMS). Although both store and retrieve data, they are designed in different ways and are suited to different types of problems.</p> <p>SQL databases organize data into structured tables made of rows and columns, following the relational database model. The database enforces strict rules such as unique identifiers, relationships between tables, and integrity constraints. This strong structure makes SQL databases reliable and predictable, which is why they are commonly used in systems where accuracy and correctness are essential, such as banking systems, university registration systems, airline reservations, and other applications where data relationships must always be maintained.</p> <p>NoSQL databases take a more flexible approach. Instead of fixed tables, they store data using formats such as documents, key-value pairs, graphs, or wide columns. This flexibility allows the database to adapt easily when the structure of the data changes or when very large amounts of data must be stored and accessed quickly. As a result, NoSQL databases are often used in social networks, messaging platforms, recommendation systems, and applications that handle large volumes of unstructured or rapidly changing data.</p> <p>The key difference between SQL and NoSQL lies in their priorities. SQL databases emphasize structure, well-defined relationships, and correctness. NoSQL databases emphasize flexibility, scalability, and performance at large scale. For example, a bank would typically use a SQL database because financial data must remain accurate and consistent. In contrast, a chat application or social media platform may prefer a NoSQL database because it must handle millions of messages or posts per second and adapt quickly to changing data formats.</p> <p>In practice, many modern systems use both approaches together: SQL databases for core, structured data that must remain reliable, and NoSQL databases for components that require high scalability and flexibility, such as logs, messages, user activity feeds, and analytics.</p>"},{"location":"Lecture_Notes/09_database/#database-transactions","title":"Database Transactions","text":"<p>A transaction moves the database from one consistent state (State A) to another consistent state (State B) by executing a sequence of operations (Operation 1, Operation 2, Operation 3, etc.). If all operations succeed, the transaction is committed. Commit means that the database permanently saves all changes made during the transaction. Once committed, the changes become part of the database and cannot be automatically undone. If any operation fails (due to an error, constraint violation, or system crash), the transaction is rolled back. Rolling back means the database discards all changes made during the transaction and returns to the previous consistent state (e.g. State A). It is as if the transaction never happened.</p>   **_Example._** Consider withdrawing money from an ATM.  **State A:** Your balance is 100 AZN.  **Operation 1:** ATM checks if cash is available.  **Operation 2:** ATM dispenses 10 AZN cash.  **Operation 3:** System deducts 10 AZN from your balance.  **State B:** Your balance is now 90 AZN.  If all operations succeed \u2192 **COMMIT** \u2192 Your balance permanently becomes 90 AZN. If Operation 2 fails (ATM runs out of cash) \u2192 **ROLLBACK** \u2192 No money is dispensed AND your balance stays 100 AZN.  The database ensures you are not charged for money you did not receive. This commit/rollback mechanism is what makes transactions reliable and is enforced by the ACID properties described below."},{"location":"Lecture_Notes/09_database/#acid-properties","title":"ACID Properties","text":"<p>ACID describes the four rules a transaction must follow for the database to stay correct.</p> <p>A for Atomicity. A transaction must be completed fully, or not at all</p>   **_Example._** You transfer 20 AZN from your Bank Account A to Account B.  Two steps occur: 1) Subtract 20 AZN from A, 2) Add 20 AZN to B.  If step 2 fails (network crash), step 1 must be undone. Atomicity ensures money does not \"disappear\".  <p>C for Consistency. The database must move from one valid state to another valid state</p>   **_Example._** If a rule says \"GPA must be between 0.0 and 4.0\", the database should never allow a transaction that sets GPA to 7.0.  <p>I for Isolation. Even if many users are working at the same time, each transaction should behave as if it is running alone. It is known as concurrency control</p>   **_Example._** Two students should not be allowed to register for the last available seat in a class at the same time.  <p>D for Durability. Once a transaction is completed, its result must stay, even if the computer crashes</p>   **_Example._** If you successfully buy a ticket and the system confirms it, the reservation should not disappear because of a power outage one second later.  <p>Traditional relational database systems were designed to manage structured data stored on a single logical database, often running on one machine or a tightly controlled cluster. In this setting, the primary challenge is to ensure that concurrent transactions behave correctly. This led to the ACID properties, which define what it means for a transaction to be reliable. ACID focuses on correctness: transactions should either fully succeed or fully fail, preserve database rules, remain isolated from one another, and survive system crashes. These guarantees are practical and achievable when the system operates under centralized control and reliable coordination.</p> <p>In contrast, many NoSQL systems were designed for large-scale, distributed environments spread across multiple machines and data centers. In such systems, network delays and failures are unavoidable, and it is not always possible to maintain strong coordination between all nodes. For this reason, the central concern shifts from transaction correctness to system behavior under network partitions. This is captured by the CAP theorem described below.</p>"},{"location":"Lecture_Notes/09_database/#cap-theorem","title":"CAP Theorem","text":"<p>CAP theorem states that a distributed data store cannot simultaneously guarantee Consistency, Availability, and Partition tolerance. For example, when a network partition occurs, the system must choose between remaining available or maintaining strict consistency. about distributed systems - a system cannot guarantee all three.</p> <p>C for Consistency. Everyone sees the same data</p>   **_Example._** If you \"like\" a photo, your friend should immediately see the updated like count.  <p>A for Availability. The system always responds.</p>   **_Example._** Even if the system is busy, Instagram must show _something_.  <p>P for Partition Tolerance. System still works even when network between servers breaks</p>   **_Example._** If some servers cannot talk to each other (network issue), the app should not fully shut down.  <p>This leads to trade-offs. For example, WhatsApp must always deliver messages (availability + partition tolerance). BUT sometimes messages appear out of order \u2192 consistency is temporarily sacrificed. No distributed large-scale system can fully satisfy all three in every situation.</p>   **_Exercise._** Provide an example of a scenario, where A or P is sacrificed."},{"location":"Lecture_Notes/09_database/#additional-material","title":"Additional Material","text":"<ul> <li>7 Database Paradigms</li> <li>Binary Search Algorithm in 100 Seconds</li> <li>SQL Explained in 100 Seconds</li> <li>ACID Properties in Databases With Examples</li> <li>CAP Theorem Simplified</li> <li>MongoDB in 100 Seconds</li> <li>Understanding B-Trees: The Data Structure Behind Modern Databases</li> <li>SQL vs NoSQL or MySQL vs MongoDB</li> <li>PostgreSQL in 100 Seconds</li> </ul> <p>{% include lecture-footer.html %}</p> <ol> <li> <p>If you don't know what to choose, usually you cannot go wrong with PostgreSQL which also happens to be open-source.\u00a0\u21a9</p> </li> </ol>"},{"location":"Lecture_Notes/10_ai/","title":"10. Artificial Intelligence, Machine Learning, Deep Learning","text":"<p>Info</p> <ul> <li>Nilufar Ismayilova, Rumiyya Alili, Ismayil Shahaliyev</li> <li>Nov 29 2025 / Dec 23 2025</li> </ul>"},{"location":"Lecture_Notes/10_ai/#purpose-of-ai-machine-learning-and-deep-learning","title":"Purpose of AI, Machine Learning and Deep Learning","text":"<p>Artificial Intelligence (AI) refers to the field concerned with building computer systems that exhibit intelligent behavior. An AI system is one that can reason, plan, make decisions, solve problems, or act purposefully in an environment in pursuit of goals. The defining feature of AI is what the system does, not how it is implemented. AI systems do not need to learn from data: classical rule-based expert systems, symbolic logic engines, search and planning algorithms, and game-playing systems based on handcrafted rules are all examples of AI. Learning may be used in AI, but it is not required.</p> <p></p> <p>By Original file: Avimanyu786; SVG version: Tukijaaliwa - File:AI-ML-DL.png, CC BY-SA 4.0, link</p> <p>Machine Learning (ML) is a methodological approach in which systems learn patterns or functions from data instead of being programmed with explicit rules. The central idea of ML is performance improvement through experience. Given examples, the system infers statistical regularities that allow it to make predictions or decisions on new data. Many ML systems perform narrow tasks such as regression, classification, clustering, or recommendation without reasoning, planning, or goal-directed behavior.</p> <p>Deep Learning (DL) is a specific class of ML methods based on multi-layer neural networks. DL is especially effective for perceptual tasks such as image recognition, speech processing, and natural language understanding because it can automatically learn features directly from raw inputs. DL is neither synonymous with intelligence nor with learning in general; it is a particular computational technique for large-scale function approximation within ML.</p> <p>Note</p> <p>An online clothing store can use AI to recommend outfits. If the store uses hand-written rules such as \u201cif user clicks blue shirts, recommend jeans\u201d, that is AI without ML. If the store learns recommendations from user behavior data (views, purchases, returns), that is ML. If the store also learns directly from product images (styles like \u201cstriped\u201d, \u201coversized\u201d, \u201ccasual\u201d), that is DL.</p>"},{"location":"Lecture_Notes/10_ai/#linear-regression-algorithm","title":"Linear Regression Algorithm","text":"<p>Linear Regression is one of the simplest ML algorithms. We assume that there is a linear relationship between the observed data and the prediction we wish to make. In that case, we can model the relationship between two variables by finding a straight line that best fits the data. The goal is to predict an output \\(\\hat{y}\\) based on an input \\(x\\) using the function:</p> \\[ \\hat{y} = wx + b \\] <p>Here \\(x\\) is the input, \\(w\\) is the weight (slope), and \\(b\\) is the bias (intercept). The task of ML is to find \\(w\\) and \\(b\\) that make predictions close to the ground truth labels. Learnable values of a model are called parameters. For comparison, GPT-3 has 175 billion parameters learned from a very large corpus of text.</p> <p>Note</p> <p>A company wants to predict exam score from study hours. It observes historical data such as (5 hours \u2192 45), (10 \u2192 55), (13 \u2192 82), (20 \u2192 94). With some choice of \\(w\\) and \\(b\\), the model can predict a reasonable score for 19 hours even if 19 never appeared in the data.</p>"},{"location":"Lecture_Notes/10_ai/#root-mean-squared-error-rmse","title":"Root Mean Squared Error (RMSE)","text":"<p>When training an ML model, we need a way to measure how well it is performing. This measurement is called loss (error), and it tells us how far predictions are from actual values. The goal of training is to minimize this loss.</p> <p>Consider this dataset:</p> Study Hours (\\(x\\)) Actual Score (\\(y\\)) Predicted Score (\\(\\hat{y}\\)) Error (\\(y-\\hat{y}\\)) 5 50 45 5 10 55 55 0 20 90 95 -5 <p>If we average errors directly, positive and negative errors cancel: $$ (5 + 0 + (-5))/3 = 0 $$ A mean error of zero does not mean the model is perfect.</p> <p>Exercise. How would you avoid negative values cancelling each other out during averaging?</p> <p>A common solution is Mean Absolute Error (MAE): $$ MAE = (|5| + |0| + |-5|)/3 = 10/3 \\approx 3.33 $$</p> <p>Another is Mean Squared Error (MSE), which penalizes large errors more strongly: $$ MSE = (5^2 + 0^2 + (-5)^2)/3 = (25 + 0 + 25)/3 \\approx 16.67 $$</p> <p>Because MSE has squared units, we take the square root to return to original units: $$ RMSE = \\sqrt{MSE} = \\sqrt{16.67} \\approx 4.08 $$</p>"},{"location":"Lecture_Notes/10_ai/#artificial-neural-networks","title":"Artificial Neural Networks","text":"<p>Artificial Neural Networks (ANNs) are inspired by how biological neurons process information. Artificial neurons pass numerical values forward through the network.</p> <p></p> <p>Structure of a typical neuron with Schwann cells in the peripheral nervous system (source: \"Anatomy and Physiology\" by the US National Cancer Institute's Surveillance, CC BY-SA 3.0, link)</p> <p>A single artificial neuron computes a linear combination of inputs and then applies a nonlinear activation function:</p> \\[ z = w_1x_1 + w_2x_2 + \\dots + w_nx_n + b \\] <p>Using the sigmoid function: $$ \\hat{y} = \\frac{1}{1 + e^{-z}} $$</p> <p>Sigmoid outputs values in \\([0,1]\\), which is often interpreted as a probability.</p> <p></p> <p>Funcs - Own work (CC0, link)</p> <p></p> <p>By Glosser.ca - Own work, derivative of File:Artificial neural network.svg, CC BY-SA 3.0, link</p> <p>A neural network is a collection of neurons. In a multilayer perceptron, outputs of one layer become inputs to the next. Output layers can contain multiple neurons, each representing a different prediction.</p> <p>Note</p> <p>For digit recognition (0\u20139), a network can have 10 output neurons. Each output can be interpreted as a probability for one digit, and the model predicts the digit with the highest value.</p>"},{"location":"Lecture_Notes/10_ai/#matrix-multiplication","title":"Matrix Multiplication","text":"<p>Matrix multiplication is one of the most important operations in ML/DL because it is how neural networks transform information. A layer stores its weights in a matrix. Inputs are represented as vectors. A forward pass is largely a sequence of matrix\u2013vector multiplications.</p> <p>Because deep learning requires many large matrix operations, hardware that can perform parallel computation is valuable. This is why GPUs are widely used: they can perform thousands of small multiplications in parallel.</p> <p>Note</p> <p>If an input vector \\(X\\) has three features and the weight matrix \\(W\\) maps those features into three outputs, the output is \\(Y = WX\\). This same operation, scaled up to large dimensions, is repeated across layers and across millions of training examples.</p>"},{"location":"Lecture_Notes/10_ai/#large-language-models-llm","title":"Large Language Models (LLM)","text":"<p>Large Language Models (LLMs), such as GPT-based systems, are deep learning models trained on extremely large text collections. They learn statistical patterns of language and can generate text, answer questions, summarize documents, translate, and write code.</p> <p>Most modern LLMs are based on the Transformer architecture. Its attention mechanism allows the model to relate each word to every other word in the input. This enables parallel processing and helps represent long-range dependencies.</p> <p>Note</p> <p>A customer-support LLM can be trained on past chat logs, troubleshooting guides, and manuals. When a user writes \u201cmy internet disconnects every hour\u201d, the model uses attention to relate tokens like \u201cinternet\u201d, \u201cdisconnects\u201d, and \u201chour\u201d, then generates a response by predicting likely next tokens conditioned on the full context.</p> <p>AI is often treated as synonymous with deep learning. This is misleading. Deep learning is one tool within AI. Many AI systems use symbolic reasoning, search, and optimization without learning from data.</p> <p>Examples include constraint satisfaction problems, minimax search in games, and reinforcement learning methods such as Q-learning. These approaches remain important in planning, scheduling, verification, and control.</p>"},{"location":"Lecture_Notes/10_ai/#constraint-satisfaction-problems-csp-and-backtracking","title":"Constraint Satisfaction Problems (CSP) and Backtracking","text":"<p>Constraint Satisfaction Problems (CSPs) require assigning values to variables so that all rules are satisfied. Each variable has a domain of allowed values. Constraints specify which assignments are permitted.</p> <p>Backtracking explores assignments systematically. It assigns values step by step, checks constraints early, and reverses (backtracks) as soon as it detects a conflict. This avoids exploring entire branches of the search space that cannot lead to a solution.</p> <p>Note</p> <p>Sudoku can be solved by backtracking. Each empty cell must be assigned a number 1\u20139 while respecting row, column, and 3\u00d73 grid constraints. If a choice violates a rule, the algorithm removes it and tries another value.</p>"},{"location":"Lecture_Notes/10_ai/#minimax-algorithm","title":"Minimax Algorithm","text":"<p>Minimax is used in two-player, turn-based games such as tic-tac-toe, chess, and checkers. One player chooses moves to maximize the outcome while assuming the opponent chooses moves to minimize it. The algorithm explores possible futures, assigns scores to outcomes, and selects the move that guarantees the best worst-case result.</p> <p>Note</p> <p>In tic-tac-toe, minimax can assign +1 to a forced win, 0 to a draw, and -1 to a forced loss. The algorithm chooses the move with the best guaranteed score, assuming the opponent plays perfectly.</p> <p>Modern chess engines use minimax-style search with many enhancements. Stockfish is a leading open-source chess engine and uses strong search methods, now also combined with neural network evaluation after the rise of AlphaZero.</p>"},{"location":"Lecture_Notes/10_ai/#reinforcement-learning","title":"Reinforcement Learning","text":"<p>Reinforcement Learning (RL) is a branch of AI where an agent learns by interacting with an environment. The agent takes actions, observes outcomes, and receives a numerical reward or penalty. Over time, it learns a policy that maximizes long-term reward by balancing exploration and exploitation.</p> <p>Key concepts:</p> <ul> <li>Agent: the learner (robot, program, game player)</li> <li>Environment: what the agent interacts with</li> <li>Action: what the agent can do</li> <li>Reward: feedback signal</li> <li>Policy: the strategy the agent learns</li> </ul> <p>Note</p> <p>A robot can learn to walk by trial and error. Actions that keep it balanced give positive reward, actions that make it fall give negative reward. Over many interactions, it learns movement patterns that reliably produce higher reward.</p>"},{"location":"Lecture_Notes/10_ai/#additional-materials","title":"Additional Materials","text":"<ul> <li>Linear Regression</li> <li>TensorFlow Playground</li> <li>TensorSpace Playground</li> <li>Tiktokenizer</li> <li>But what is a neural network? Deep learning chapter 1</li> <li>Machine Learning Explained in 100 Seconds</li> <li>Linear Regression in 3 Minutes</li> <li>AI vs ML vs DL vs Data Science - Difference Explained Simplilearn</li> <li>N-Queens - Backtracking - Leetcode 51 - Python</li> <li>Minimax: How Computers Play Games</li> <li>Matrix multiplication as composition Chapter 4, Essence of linear algebra</li> <li>Multiplying a matrix by a matrix Khan Academy</li> <li>Large Language Models explained briefly</li> <li>How I use LLMs</li> <li>Deep Dive into LLMs like ChatGPT</li> <li>Machine Learning Fundamentals: Bias and Variance</li> <li>How Cambridge Analytica Exploited the Facebook Data of Millions NYT</li> <li>AlphaGo - The Movie Full award-winning documentary</li> <li>AI Learns to Play Soccer (and breaks physics)</li> </ul>"},{"location":"Lecture_Notes/11_sdlc/","title":"11. Systems Development Life Cycle","text":"<p>Info</p> <ul> <li>Rahida Asadli, Rumiyya Alili, Ismayil Shahaliyev</li> <li>Dec 15 2025 / Dec 24 2025</li> </ul> <p>Systems Development Life Cycle (SDLC) is a framework that guides the creation of an information system from initial idea to a working product. It describes the process of identifying system requirements, designing the system, building it, and deploying it to users.</p>"},{"location":"Lecture_Notes/11_sdlc/#participants-of-sdlc","title":"Participants of SDLC","text":"<p>Developing an information system is not just a technical task. It is a coordinated effort involving business decision-makers, technical specialists, and end-users, each with distinct responsibilities.</p> <p>Stakeholders are individuals or groups who are affected by the system or have an interest in its outcome. This includes managers, department heads, users, IT staff, and executives. Stakeholders provide input, set expectations, and evaluate whether the system delivers value.</p> <p>Project sponsor is a senior business representative who initiates the project by identifying a business need. The sponsor secures funding, supports the project at the executive level, and acts as the main business authority. Without a sponsor, a project usually lacks direction and protection.</p> <p>Steering committee (or approval committee) is a small group of senior managers and stakeholders. This group reviews major decisions, evaluates feasibility, approves budgets, and decides whether the project should start, continue, change direction, or be stopped. Their role is governance, not day-to-day work.</p> <p>Project manager is responsible for planning and controlling the project. This role creates schedules, manages costs, assigns tasks, tracks progress, and resolves risks. The project manager coordinates all participants and ensures that work across phases stays aligned with time, budget, and scope.</p> <p>Systems analyst focuses on how the information system supports the organization. This role studies current workflows, identifies problems, translates business needs into system requirements, and helps design the overall solution. Systems analysts bridge the gap between business and technology.</p> <p>Business analyst concentrates on business value and process improvement. This role examines how work is done today, identifies inefficiencies, defines new business rules, and ensures the system delivers measurable benefits. Business analysts speak the language of management and operations.</p> <p>Requirements analyst is responsible for gathering, documenting, and validating detailed system requirements. This role works closely with users and stakeholders to ensure requirements are clear, complete, and unambiguous. Good communication is critical here, because unclear requirements lead to system failure.</p> <p>Infrastructure analyst handles the technical foundation of the system. This includes servers, networks, databases, operating systems, and integration with existing systems. The infrastructure analyst ensures the system is reliable, scalable, and compliant with organizational standards.</p> <p>Change management analyst focuses on people, not technology. This role prepares users for the new system through training, documentation, communication, and support. The goal is to reduce resistance, ensure adoption, and help the organization adjust to new ways of working.</p> <p>Programmers and developers build the system based on the approved design. They write code, integrate components, and implement system functionality.</p> <p>Testers verify that the system works correctly. They check for errors, validate that requirements are met, and ensure the system behaves as expected under real conditions.</p> <p>Users (end-users) are the people who will use the system daily. They provide requirements, review designs, test early versions, and ultimately determine whether the system is successful. A system that users do not accept or trust will fail, regardless of technical quality.</p> <p>These labels describe roles, not fixed job titles. A role represents a set of responsibilities that must be performed for a system to be successfully developed, regardless of who performs them. In practice, organizations rarely use these exact titles. Instead, job titles emerge based on company size, structure, industry, and methodology. One person may carry out several roles under a single title, or a single role may be shared across multiple people. What matters is that the functions\u2014decision-making, requirement definition, technical design, implementation, testing, and user adoption\u2014are covered, even if the titles used in the organization are different or change over time.</p>"},{"location":"Lecture_Notes/11_sdlc/#phases-of-sdlc","title":"Phases of SDLC","text":"<p>The SDLC typically consists of four fundamental phases\u2014planning, analysis, design, and implementation\u2014each with its own steps, techniques, and deliverables.</p> <p>Note</p> <p>Think of it like building a house. First, you decide why you need the house and what problems it must solve\u2014how many rooms it should have, who will live in it, and how much you can spend (planning). Next, you write down exact requirements: the number of floors, room sizes, plumbing, electricity, heating, and safety rules (analysis). Then you turn these requirements into precise drawings and technical plans that builders can follow, showing layouts, measurements, and materials (design). Finally, the house is built according to these plans, utilities are installed, and everything is checked to make sure it works as expected before people move in (implementation). Each step produces concrete results that guide the next step, and earlier decisions may be adjusted as new issues are discovered.</p>"},{"location":"Lecture_Notes/11_sdlc/#planning-phase","title":"Planning Phase","text":"<p>The main goal of the planning phase is to understand why an information system should be built and to decide how the project will be organized and managed. Before any system is designed or built, the organization must be sure that the project is necessary, realistic, and valuable.</p> <p>During project initiation, a business need or problem is identified. This need usually comes from a business department rather than the IT department. The idea for the new system is written in a document called a system request, which briefly explains the problem, the reason a system is needed, and how it is expected to help the organization. The person or department that proposes the system is known as the project sponsor.</p> <p>After the system request is prepared, a feasibility analysis is conducted. This analysis checks whether the project should move forward by examining three important areas.</p> <p>Technical feasibility asks whether the system can actually be built using the organization's current technology, skills, and resources: Can we build it?</p> <p>Note</p> <p>If a company wants to develop a mobile banking application, it must check whether it has developers with mobile programming skills, secure servers, and the ability to connect the app to existing banking systems. If these resources are missing, the project may not be technically feasible.</p> <p>Economic feasibility focuses on whether the system is worth its cost. It compares the expected benefits with the total costs of development, operation, and maintenance: Should we build it?</p> <p>Note</p> <p>If a supermarket plans to install self-checkout machines, it must consider whether the reduction in staff costs and faster checkout times will save more money than the cost of purchasing and maintaining the machines. If the benefits are greater than the costs, the project is economically feasible.</p> <p>Organizational feasibility examines how the system will fit within the organization and whether people will accept and use it. A system can fail even if it is technically and economically sound, simply because users resist it: If we build it, will users accept it?</p> <p>Note</p> <p>If a university introduces a new online attendance system, it must ensure that lecturers and students are willing to use it and that proper training is provided. Strong management support is also essential for organizational feasibility.</p> <p>Once the feasibility analysis is completed, the system request and analysis results are reviewed by an approval committee, often called a steering committee. This committee decides whether the project should be approved, changed, or rejected.</p> <p>If the project is approved, it moves into project management, which is the second step of the planning phase. At this stage, the focus shifts from deciding whether to build the system to deciding how the work will be carried out. The project manager breaks the project into specific tasks, estimates how long each task will take, identifies required resources, and assigns responsibilities to team members. A detailed schedule is created, showing task order, dependencies, milestones, and deadlines. The project manager also prepares a budget, identifies major risks, and defines how progress will be monitored and reported. This project plan becomes the roadmap for the entire system development effort and is used throughout the SDLC to track progress, control costs, and manage changes.</p>"},{"location":"Lecture_Notes/11_sdlc/#analysis-phase","title":"Analysis Phase","text":"<p>The analysis phase focuses on understanding the system in detail before it is designed or built. In this phase, the project team answers three key questions: who will use the system, what the system must do, and where and when it will be used. The goal is to clearly understand the current situation and define what the new system should achieve.</p> <p>During the analysis phase, the team first studies any existing system that is already in use. The team looks for problems, weaknesses, delays, errors, or user complaints. At the same time, they imagine how a better system could work in the future.</p> <p>Note</p> <p>If a company currently uses paper forms to track employee leave requests, analysis would study how this process works now and then imagine a future system where requests are submitted and approved online.</p> <p>The next part of the analysis phase is requirements gathering. This means collecting information about what users and managers actually need from the system. The project team talks to users, managers, and other stakeholders to understand their expectations and daily work.</p> <p>Note</p> <p>When developing a university course registration system, analysts may talk to students, instructors, and administrative staff to understand how courses are selected, approved, and recorded. From this, the team defines requirements such as allowing students to register for courses or enabling instructors to view class lists.</p> <p>Based on these requirements, the team develops a system concept. The system concept is a high-level description of how the new system will work and how it will support the organization. Analysts often create simple models showing how users interact with the system and how information flows inside it. These models focus on clarity, not implementation details.</p> <p>In the final step of the analysis phase, findings are combined into a document called the system proposal. This document includes the analysis results, the system concept, the requirements, and the models. It is presented to the project sponsor and other decision makers. They use it to decide whether the project should continue, be changed, or be stopped.</p> <p>The system proposal is the main output of the analysis phase. It may include a preliminary solution concept, but it does not contain the detailed technical blueprint. That is the purpose of the design phase.</p>"},{"location":"Lecture_Notes/11_sdlc/#design-phase","title":"Design Phase","text":"<p>The design phase focuses on deciding how the system will work. The project team defines technical details, including hardware and software choices, network setup, user interface, database structure, and the programs that must be created.</p> <p>One of the first tasks in the design phase is choosing a design strategy. The organization may build the system internally, outsource development, or buy an existing software package and adapt it.</p> <p>After the design strategy is chosen, the team creates the system architecture design, describing the overall structure of hardware, software, and network infrastructure, including how the new system connects to existing systems.</p> <p>At the same time, the team designs the user interface, defining screens, menus, buttons, forms, and reports, aiming for clarity and usability.</p> <p>The design phase also includes database and file specifications, which define what data will be stored and how it will be organized.</p> <p>Finally, the team prepares the program design, describing what programs need to be written and what each program will do. This is not coding; it is a specification for developers.</p> <p>Note</p> <p>In an online student registration system, design includes architecture (web servers for student access and database servers for enrollment data), user interface behavior (search, add, drop, confirmations), database tables (students, courses, enrollments, prerequisites), and program modules (authentication, validation, enrollment processing, reporting).</p> <p>All design outputs are combined into a single document called the system specification. This includes architecture design, interface design, database specifications, and program design. It is the main guide for programmers in the next phase. At the end of the design phase, feasibility and the project plan are reviewed again, and the sponsor and approval committee decide whether the project should continue.</p>"},{"location":"Lecture_Notes/11_sdlc/#implementation-phase","title":"Implementation Phase","text":"<p>In the implementation phase, the system is built and put into use. If the organization decided to buy an existing software package, implementation includes installing and configuring it instead of building everything from scratch.</p> <p>The first step is system construction. Programmers write code, databases are created, and components are integrated. At the same time, the system is tested to ensure it behaves as expected. Testing is critical because fixing errors after deployment can be expensive and disruptive.</p> <p>Once the system is built and tested, the next step is system installation, which switches from the old system to the new one. This may involve shutting down the old system, or running both in parallel for a short period. A key part of installation is user training so users can work confidently and correctly.</p> <p>The final step is creating a maintenance (support) plan. This explains how the system will be supported after it goes live. It often includes a post-implementation review to check whether goals were met and whether users are satisfied. The plan also defines how problems will be fixed, how updates will be handled, and how users can get help.</p> <p>Together, these steps ensure the system is built correctly, adopted by users, and supported over time.</p> <p>Note</p> <p>Fixing errors after deployment is often far more expensive than fixing them during development. A failure in an online banking transaction system is not just a bug; it can cause direct financial loss and destroy trust.</p> <p>Exercise. Why follow a system development life cycle with phases described above?</p>"},{"location":"Lecture_Notes/11_sdlc/#approaches-to-sdlc","title":"Approaches to SDLC","text":"<p>The phases above can be organized in different ways. Below are several common approaches, with typical advantages and disadvantages.</p>"},{"location":"Lecture_Notes/11_sdlc/#waterfall-development","title":"Waterfall Development","text":"<p>The waterfall model is a traditional approach that follows a linear sequence. Each phase is intended to be completed before the next one begins, with minimal overlap.</p> <p>Note</p> <p>Different textbooks describe SDLC phases and approaches differently. There is no single official SDLC. Some describe four phases (planning, analysis, design, implementation). Others separate construction and testing, or add deployment and maintenance as separate phases. What stays consistent is the logic: understand the problem, define requirements, design the solution, build it, test it, and put it into use.</p> <p>A key assumption of waterfall is that requirements remain stable after they are defined. Because changes late in the project are costly, waterfall fits projects where requirements are well understood from the beginning and formal approvals and documentation are required.</p> <p>One advantage is its clarity and structure, which makes planning, budgeting, and progress tracking easier. A major disadvantage is its inflexibility: if requirements change, rework can be expensive.</p> <p>Exercise. What other advantages and disadvantages of the waterfall model can you identify?</p>"},{"location":"Lecture_Notes/11_sdlc/#system-prototyping","title":"System Prototyping","text":"<p>The prototyping model produces a working prototype quickly. Users evaluate it, provide feedback, and developers iterate until it becomes the final system. This approach clarifies requirements through direct user interaction, but if rushed, it can lead to weak architecture.</p> <p>Note</p> <p>A university can start with a basic course registration prototype. Students test it, request changes, and developers iterate until the system becomes stable enough for real use.</p> <p>Throwaway prototyping uses prototypes as a learning tool. The team builds prototypes to explore alternatives, clarify uncertainties, and test technical feasibility, then discards them and builds the real system using proper architecture and standards.</p> <p>Note</p> <p>Before building a hospital patient management system, a team may prototype registration and appointment scheduling with mock data. After discovering missing requirements and confusing workflows, the prototype is discarded and the real system is designed and implemented properly.</p>"},{"location":"Lecture_Notes/11_sdlc/#minimum-viable-product-mvp","title":"Minimum Viable Product (MVP)","text":"<p>A Minimum Viable Product (MVP) is the simplest version of a product that delivers value to early users and allows a team to test assumptions. It includes only the core features, with everything else deferred, so the team can learn quickly and avoid waste.</p> <p>Although prototyping and MVP development are both iterative, they differ in purpose. Prototyping is usually aimed at clarifying requirements for building the right system inside an organization. An MVP is aimed at validating whether the product is worth building in a market setting.</p> <p>Exercise. Describe advantages and disadvantages of prototyping and MVP approaches compared to the waterfall model.</p>"},{"location":"Lecture_Notes/11_sdlc/#agile-development","title":"Agile Development","text":"<p>Agile development was created in response to waterfall limitations, especially where requirements change frequently. Agile emphasizes flexibility, collaboration, and continuous improvement. Work is delivered in small increments, user feedback is collected regularly, and changes are welcomed even late in development.</p> <p>A key reference is the Agile Manifesto, which prioritizes individuals and interactions, working software, customer collaboration, and responding to change.</p> <p>One popular agile method is Scrum, which organizes work into short cycles called sprints (often 2\u20134 weeks). Each sprint delivers a set of features that are designed, built, tested, and reviewed.</p> <p>Agile\u2019s advantages include flexibility, strong user involvement, and quicker delivery of value. Its disadvantages include the need for active user participation, strong team coordination, and difficulty in long-term planning if scope is not controlled.</p> <p>Exercise. What other advantages and disadvantages of agile development can you identify?</p>"},{"location":"Lecture_Notes/11_sdlc/#unified-modeling-language-uml","title":"Unified Modeling Language (UML)","text":"<p>Unified Modeling Language (UML) is a standardized visual language used to analyze, design, and communicate how an information system should work. It is used mainly during the analysis and design phases to make requirements and design decisions clear for both technical and non-technical stakeholders.</p> <p></p> <p>A class diagram describes the static structure of a system: classes, attributes, and relationships.</p> <p>A sequence diagram shows how objects interact over time to complete a use case.</p> <p>Exercise. Create a use case diagram, class diagram, and sequence diagram for an online course registration system. The system should allow students to enroll in courses, drop courses, and view schedules. It should allow administrators to manage courses and student records.</p>"},{"location":"Lecture_Notes/11_sdlc/#software-testing","title":"Software Testing","text":"<p>Software testing is the process of evaluating a system to determine whether it functions correctly and meets specified requirements. Testing is performed throughout the SDLC, with different types of testing focusing on different levels of the system.</p> <p>Unit testing tests individual functions, methods, or classes in isolation, usually by developers.</p> <p>Integration testing checks how modules work together, focusing on interfaces and data flow.</p> <p>System testing evaluates the complete system against functional and non-functional requirements such as performance, security, and reliability.</p> <p>User acceptance testing (UAT) is performed by end users or customer representatives to confirm the system supports real business tasks and is ready for operational use.</p> <p>Regression testing ensures that changes or bug fixes have not broken existing functionality by re-running previously executed tests.</p>"},{"location":"Lecture_Notes/11_sdlc/#extreme-programming-xp","title":"Extreme Programming (XP)","text":"<p>Extreme programming (XP) is an agile approach that emphasizes close collaboration, continuous feedback, and high-quality code. Short iterations deliver working functionality regularly. Pair programming supports code quality and knowledge sharing. Unit testing and continuous integration enable safe changes and reduce late-stage integration problems.</p>"},{"location":"Lecture_Notes/11_sdlc/#joint-application-development-jad-jad","title":"Joint Application Development (JAD) {#jad}","text":"<p>Joint Application Development (JAD) is a structured technique for gathering and defining system requirements through facilitated workshops. Users, managers, analysts, and developers work together to reach shared understanding and make decisions quickly.</p> <p>JAD is typically used during the analysis phase, especially for systems with many stakeholders or complex business rules. A trained facilitator keeps sessions focused and ensures all viewpoints are heard. The outcome is a clearer set of requirements and stronger user ownership.</p> <p>Note</p> <p>When developing a company-wide reporting system, representatives from finance, operations, and management join JAD workshops with analysts. They agree on required reports, data definitions, and business rules early, which reduces later change requests and increases acceptance.</p>"},{"location":"Lecture_Notes/11_sdlc/#additional-material","title":"Additional Material","text":"<ul> <li>Software Development Life Cycle: Explained</li> <li>Estimate Software Development Costs</li> <li>Software Planning and Technical Documentation</li> <li>What is Agile?</li> <li>UML use case diagrams</li> <li>UML class diagrams</li> <li>Software Testing Explained in 100 Seconds</li> </ul>"},{"location":"Lecture_Notes/12_ethics/","title":"12. Ethics, Security, and Logical Reasoning","text":"<p>Info</p> <ul> <li>Nilufar Ismayilova, Rumiyya Alili, Ismayil Shahaliyev</li> <li>Nov 29 2025 / Dec 25 2025</li> </ul> <p>The most dangerous phrase in the language is: \"We've always done it this way\".</p> <p>~ Grace Hopper</p>"},{"location":"Lecture_Notes/12_ethics/#space-shuttle-challenger-disaster","title":"Space Shuttle Challenger Disaster","text":"<p>One of the most important historical examples used to discuss ethics in engineering and information systems is the Space Shuttle Challenger disaster (1986). The Challenger shuttle broke apart shortly after launch, resulting in the deaths of all seven crew members.</p>      Crew members of the Challenger shuttle: (back) Onizuka, McAuliffe, Jarvis, Resnik; (front) Smith, Scobee, McNair. By NASA, Public Domain, link.    <p>Investigations later showed that the disaster was not caused by a single technical failure alone, but by a combination of engineering, organizational, and ethical failures. A critical technical issue involved O-ring seals in the solid rocket boosters.</p> <p>These O-rings were responsible for preventing hot combustion gases from escaping during launch. This design created a single point of failure: if the O-ring did not seal properly, there was no additional system to contain the pressure. One component became responsible for the safety of the entire mission.</p> <p>Before the Challenger launch, engineers from Morton Thiokol analyzed data from previous shuttle flights and noticed that the O-rings performed worse at lower temperatures. During a pre-launch meeting, engineers explicitly recommended delaying the launch because the temperature on launch day was far below any previous flight conditions. However, NASA managers were under pressure to maintain the launch schedule and asked engineers to provide proof that the launch would fail, instead of proof that it was unsafe. Communication problems, schedule pressure, and fear of delaying the mission played a major role in ignoring these warnings.</p>      Cross-sectional diagram of the original SRB field joint. The top end of the lower rocket segment has a deep U-shaped cavity (a clevis). Two grooves hold O-rings that seal the gap between the tang and the clevis. By Rogers Commission, Public Domain, link.    <p>This phenomenon is called normalization of deviance. NASA had seen O-ring erosion in earlier flights but accepted it as \"normal\" because flights had not failed yet. When warning signs appear repeatedly without immediate catastrophic consequences, organizations can begin to accept abnormal and risky conditions as normal. This creates a culture where critical safety concerns are downplayed, and each successful outcome despite the warnings reinforces the dangerous belief that \"it will be fine this time too.\"</p>   **_Exercise._** Identify the key ethical mistakes that occurred in the _Challenger_ shuttle case and explain what engineers and decision-makers should have done differently to ensure public safety and proper handling of technical concerns."},{"location":"Lecture_Notes/12_ethics/#trolley-problem","title":"Trolley Problem","text":"<p>Ethical questions in technology (and life) often involve difficult trade-offs, where every available option leads to some form of harm or disadvantage. One well-known thought experiment used to explore moral reasoning in such situations is the trolley problem. In its basic form, a runaway trolley is heading toward several people standing on a track. You have the option to pull a lever that redirects the trolley onto another track, where it will harm only one person instead. The dilemma forces individuals to choose between actively causing harm to one person or passively allowing greater harm to occur.</p>      Diagram (adapted from Wikimedia). CC BY-SA 4.0, link.    <p>The trolley problem has no simple or universally correct answer. Instead, it highlights how ethical decisions often involve conflicting values, such as minimizing harm, respecting individual rights, and determining responsibility for outcomes. Some people focus on the consequences of actions and choose the option that saves the most lives, while others believe it is morally wrong to actively cause harm, even if it leads to a better overall outcome.</p> <p>Consequentialism judges decisions by their outcomes. A consequentialist, especially a utilitarian, might argue that diverting the trolley is morally right because it reduces the total loss of life.</p> <p>Deontological ethics evaluates actions based on rules, duties, and respect for individual rights. From this view, deliberately causing a person's death is morally wrong regardless of the positive result.</p> <p>The scenario also engages the doctrine of double effect, which distinguishes between harm that is foreseen but unintended and harm that is used as a means to an end. Another important idea is agent responsibility: whether moral judgment depends on what we do directly versus what we merely allow to happen.</p> <p>In the context of information systems, artificial intelligence, and automation, similar dilemmas arise in real-world system design. For example, engineers developing autonomous vehicles must consider how a system should behave in unavoidable accident scenarios. Should the system prioritize the safety of passengers, pedestrians, or follow traffic laws strictly regardless of the outcome?</p>   **_Exercise._** Consider a self-driving car approaching an unavoidable accident. If the car continues forward, it will collide with several pedestrians crossing the street illegally. If it swerves, it will crash into a barrier, putting the passenger at serious risk. Should the algorithm prioritize minimizing total harm, protecting the passenger, or following traffic laws strictly? What would you choose? Why?"},{"location":"Lecture_Notes/12_ethics/#deduction-and-induction","title":"Deduction and Induction","text":"<p>Logical reasoning plays a central role in engineering, information systems, and ethical decision-making. Many of the foundational ideas behind logical reasoning were first systematized by Aristotle, who is often regarded as the founder of formal logic.</p> <p>Aristotle introduced deductive reasoning, particularly through the concept of the syllogism, which is a structured form of argument consisting of premises that lead to a necessary conclusion. In deductive reasoning, the argument moves from general principles to specific cases. If the premises are true and the logical structure is valid, the conclusion must also be true.</p>   **_Example._** Below is perhaps the most famous syllogism:  _All humans are mortal._  _Socrates is a human._  _Therefore, Socrates is mortal._     **_Exercise._** Is the argument below logically sound? If not, identify what is wrong with its reasoning.  _All secure systems require authentication._   _This system requires authentication._   _Therefore, this system is secure._   <p>In contrast, inductive reasoning moves from specific observations to broader generalizations. Rather than guaranteeing truth, induction produces conclusions that are probable or likely, based on patterns in observed data.</p>   **_Example._**  _This system failed after several cyber attacks._   _Similar systems also failed after attacks._   _Therefore, such systems are likely vulnerable._     **_Exercise._** Give an example of inductive reasoning in information systems, where conclusions are drawn from historical data rather than strict rules.   <p>Modern science relies primarily on induction. We observe patterns in data and infer general laws or predictions. Machine learning itself is grounded in induction: models infer patterns from past samples in the hope that those patterns generalize to new cases. This approach is powerful, but it never guarantees certainty.</p>   **_Important._** [Mathematical induction](https://en.wikipedia.org/wiki/Mathematical_induction) is a deductive proof method, not induction from repeated observations. Meanwhile, the so-called \"deductions\" of Sherlock Holmes are typically inductive generalizations rather than strict logical necessity.   <p>This reliance on induction raises a major philosophical issue identified by David Hume. Inductive conclusions assume that the future will resemble the past, yet there is no logical proof for this assumption.</p> <p>Karl Popper later emphasized that no amount of positive evidence can conclusively prove a scientific theory, but a single counterexample can disprove it. This is captured by the \"black swan\" illustration and the idea of falsifiability.</p>   **_Important._** Even mathematical certainty is limited by the axioms that define a system. Change those axioms, and the truths derived from them change as well. In [Euclidean geometry](https://en.wikipedia.org/wiki/Euclidean_geometry), parallel lines never intersect. In [spherical geometry](https://en.wikipedia.org/wiki/Spherical_geometry), great circles always intersect, so parallel lines do not exist. Deductive conclusions are guaranteed only if the starting assumptions are."},{"location":"Lecture_Notes/12_ethics/#ambiguity-of-language","title":"Ambiguity of Language","text":"<p>Natural language is inherently imprecise. Many disagreements in engineering, science, and ethics arise not from factual disputes but from differences in how people interpret the same words. Terms such as \"secure,\" \"harm,\" or \"responsibility\" may appear obvious, yet their meaning can shift dramatically depending on context.</p> <p>To avoid misunderstandings, we may attempt to translate vague statements into precise logical form. Aristotle took a major step by abstracting arguments away from their wording and focusing on their form:</p>   All **A** are **B**.  **C** is **A**.  Therefore, **C** is **B**.   <p>As scientific knowledge expanded, ambiguity became an increasingly serious obstacle. Gottlob Frege developed symbolic logic to separate meaning from grammar.</p> <p>Bertrand Russell and Alfred North Whitehead pursued this project in Principia Mathematica, attempting to ground mathematics in logic.</p> <p>However, this project revealed important limitations. Even if the structure of an argument is perfectly logical, its symbols must still be defined by humans. Meaning remains uncertain, especially in ethical or social contexts. Real-world decisions also involve conflicting goals and values that cannot be fully captured by rigid rules.</p>"},{"location":"Lecture_Notes/12_ethics/#asimovs-laws-of-robotics-laws","title":"Asimov's Laws of Robotics {#laws}","text":"<p>The science-fiction writer Isaac Asimov proposed the Three Laws of Robotics in 1942:</p> <ul> <li>A robot may not injure a human being or, through inaction, allow a human being to come to harm.</li> <li>A robot must obey the orders given it by human beings except where such orders would conflict with the First Law.</li> <li>A robot must protect its own existence as long as such protection does not conflict with the First or Second Laws.</li> </ul> <p>In structure, these laws resemble rule-based logic (IF/THEN constraints). While they seem protective, Asimov\u2019s own stories showed how clean rules can produce unintended outcomes. If \"prevent harm\" is interpreted literally, robots may restrict human freedom to eliminate risk.</p> <p>This illustrates a core difficulty in real system design and the broader AI alignment problem: specifying rules, objectives, or reward functions does not guarantee acceptable outcomes. Language is vague, values conflict, and context shifts.</p>   **_Example._** An AI programmed to \"maximize user engagement\" on social media might discover that divisive, inflammatory content keeps people engaged longer. The system optimizes the stated goal but produces harmful outcomes such as polarization and misinformation.     **_Exercise._** Improve the engagement objective above by proposing a clearer goal and constraints that protect user well-being, reduce misinformation, and prevent harmful content from being promoted, while still allowing the system to recommend interesting material."},{"location":"Lecture_Notes/12_ethics/#acm-code-of-ethics","title":"ACM Code of Ethics","text":"<p>Decisions made by computing professionals can protect users or put them in danger. A system can succeed technically and still fail its users through privacy violations, unfair outcomes, or unsafe deployment.</p> <p>Professional organizations such as the Association for Computing Machinery (ACM) provide codes of ethics to guide these decisions. The ACM Code emphasizes avoiding harm, honesty, fairness, privacy protection, and accountability. Ethical judgment still requires interpretation and context awareness, because ethics cannot be reduced to formulas or automated decision rules.</p>"},{"location":"Lecture_Notes/12_ethics/#viruses-and-cyber-attacks","title":"Viruses and Cyber Attacks","text":"<p>Technological advancement is not inherently good or bad: it expands capability, and that includes capability for harm. Systems that work under honest use can fail under malicious intent. Protecting users requires understanding how systems are attacked, not only how they are designed.</p> <p>Social engineering targets people rather than code. Phishing impersonates trusted institutions to steal credentials. Spear-phishing targets specific individuals or organizations.</p> <p>Malware exploits weaknesses in software and configurations. A Trojan horse appears legitimate while doing harm. Ransomware encrypts data and demands payment. Worms spread automatically. Spyware collects information silently.</p> <p>Network attacks target communication. A Man-in-the-Middle (MITM) attack intercepts or alters data. Denial-of-Service (DoS) overwhelms services so legitimate users cannot access them.</p> <p>Credential stuffing uses leaked passwords from one service to break into accounts on another. Brute-force attacks guess passwords until one succeeds.</p> <p>Wipers permanently erase data for sabotage. Clickjacking disguises harmful actions behind innocent clicks. Typosquatting exploits URL mistakes to redirect victims to fake sites.</p>   **_Example._** A student downloads a \u201cfree PDF textbook\u201d from an unofficial website. The file contains a Trojan that installs on the laptop, records keystrokes, and sends credentials to an attacker. Later, the laptop becomes part of a [botnet](https://en.wikipedia.org/wiki/Botnet) and is used in a DoS attack against a university server."},{"location":"Lecture_Notes/12_ethics/#digital-hygiene","title":"Digital Hygiene","text":"<p>Digital hygiene refers to everyday habits that protect devices, personal data, and online identity. It focuses on regular preventive actions rather than reacting only after damage occurs.</p> <p>Using strong, unique passwords reduces the risk of account takeover. Password managers help generate and store unique passwords, but they introduce a single point of failure: if the master password is compromised, many accounts may be exposed. Multi-factor authentication (MFA) reduces this risk by adding a second verification step.</p> <p>Users should avoid relying on any single device or storage location. Regular backups, ideally stored offline or in a trusted cloud service, reduce the damage of ransomware, device failure, or accidental deletion. The goal is to avoid single points of failure for anything important.</p> <p>Keeping software and operating systems updated is essential, as updates often patch known security vulnerabilities. Users should also avoid suspicious links and untrusted downloads, and be cautious when sharing personal information online, since attackers use such details to craft convincing phishing attempts.</p> <p>Using secure networks reduces exposure to eavesdropping and interception, especially when accessing banking or university services. Together, these practices form a practical and proactive defense.</p>"},{"location":"Lecture_Notes/12_ethics/#additional-materials","title":"Additional Materials","text":"<ul> <li>Challenger Distaster</li> <li>Consequentialism vs. Deontology</li> <li>Absurd Trolley Problems</li> <li>AI Decides on Absurd Trolley Problems</li> <li>David Hume and the Problem of Induction</li> <li>The Ascent of Money Episode 3: Blowing Bubbles</li> <li>Aristotle: Logic Internet Encyclopedia of Philosophy</li> <li>Isaac Asimov - Laws of Robotics - Extra Sci Fi</li> <li>ACM Code of Ethics</li> <li>Theranos - Silicon Valley's Greatest Disaster</li> <li>Every Type of Computer Virus Explained in 8 Minutes</li> <li>Every Type of Cyber Attack Explained in 8 Minutes</li> <li>Digital hygiene</li> </ul>"},{"location":"course/2025_fall/","title":"Fall 2025","text":""},{"location":"course/2025_fall/#schedule","title":"Schedule","text":"Day Time 10425 10426 10427 10428 10429 10430 10431 10432 10640 Mon 08:30 E125 E125 E125 E125 E125 E125 E125 E125 E125 Tue 08:30 B303 Tue 10:00 A301 Tue 14:30 D208 Tue 16:00 B101 Thu 08:30 B203 Fri 08:30 B302 Fri 10:00 B302 Fri 13:00 B102 Sat 11:30 B303"},{"location":"course/2026_spring/","title":"Spring 2026","text":"<p>Important</p> <p>The content is subject to change. Please consistently check the course page on Blackboard and the ADA University Academic Calendar for modifications. The last day of the add/drop period, holidays, and similar dates are noted in the calendar.</p> Week Topic Learning Outcomes Assessment / Notes 1 Course Overview / Syllabus / Technology &amp; Engineering Describe the course structure and ground rules as defined in the syllabus. Define and describe the challenges of technology and engineering. \u2014 2 Data, Information, Knowledge / Statistics / Systems / Information Systems Differentiate between data and information. Describe the role of statistics. Define a system, its components, and interactions. Describe information systems and components of computer-based IS. \u2014 3 Digital vs Analog / Data Units / Number Systems / Binary Arithmetic / Two\u2019s Complement / Transistors / Boolean Logic Compare digital and analog systems. Define bit, byte, and data units. Convert numbers between decimal, binary, and hexadecimal. Explain binary addition, subtraction, and two\u2019s complement. Describe Boolean logic, truth tables, transistors, and logic gates. Project 1 out [Team]: Constructing basic logic gates 4 Hardware: CPU, GPU, Memory, I/O, Storage Explain von Neumann architecture. Describe CPU components and operation. Explain GPU purpose. Differentiate memory types (ROM, RAM, cache), DRAM vs SRAM, and secondary storage technologies. Homework 1 out: JavaScript programming 5 Algorithms I: Name Binding, Selection, Repetition Define algorithms. Explain basic algorithmic actions: name binding, selection, repetition. Project 2 out [Team]: Hour of Code 6 Algorithms II: Modularization, Recursion / Dijkstra\u2019s Algorithm Explain modularization and recursion. Describe Dijkstra\u2019s shortest path algorithm. \u2014 7 Software / Software Engineering / Programming Languages / Compilers &amp; Interpreters / Operating Systems Define software and software engineering. Explain best practices in software development. Differentiate syntax vs semantics. Explain programming paradigms and language evolution. Compare compiler and interpreter. Describe OS roles and activities. Midterm Exam: March 10 (Tuesday) 8 Telecommunications / Computer Networks / OSI Model / Network Topologies Describe telecommunication models and media. Explain network classifications and characteristics. Describe computer networks and OSI layers. Compare network types and topologies. Project 3 out [Team]: Programming LEGO robots 9 Internet / IP Suite / Addressing / DNS / Routing / Intranet &amp; Extranet / Distributed Systems Describe Internet structure. Explain IP suite, IP and MAC addresses. Describe DNS and routing. Define intranet, extranet, and distributed systems. \u2014 10 World Wide Web / Markup Languages / Cloud Computing / System Architectures Describe WWW structure and HTTP. Explain URLs. Describe markup languages. Explain cloud computing models and centralized vs decentralized systems. Homework 2 out: SQL 11 Databases / Data Models / Indexing / Normalization / Big Data Explain database approach and advantages. Describe ER modeling and indexing. Explain relational model and normalization. Define Big Data and knowledge discovery. \u2014 12 DBMS / SQL / NoSQL / Transactions / ACID / CAP Explain DBMS types and purposes. Describe data manipulation operations. Explain SQL commands. Contrast SQL and NoSQL. Explain transactions, ACID properties, and CAP theorem. Project 4 out [Individual]: Personal portfolio website 13 AI / ML / DL / Regression / Neural Networks / LLMs Define AI, ML, DL. Explain regression and classification. Describe supervised vs unsupervised learning. Explain linear regression and RMSE. Describe neural networks, LLMs, CSP backtracking, minimax, and reinforcement learning. \u2014 14 Systems Development / SDLC / Waterfall / Agile / Prototyping / Testing / UML Identify SDLC phases, participants, and outputs. Compare SDLC models. Explain DevOps and software testing. Describe UML diagrams (use case, class, sequence). \u2014 15 Engineering Ethics / Security / Privacy / Logic / Digital Hygiene Explain engineering ethics and social responsibility. Describe logical reasoning and fallacies. Outline ACM Code of Ethics. Explain digital hygiene and social issues of information systems. \u2014 \u2014 \u2014 \u2014 Final Exam: May 13 (Wednesday)"},{"location":"general/communication/","title":"Communication Rules","text":"<p>As the course is massive with hundreds of students, you are expected follow the communication rules throughout the semester. There are two options to communicate with instructors: 1) via virtual office hours on the course blackboard page, 2) via email.</p>"},{"location":"general/communication/#virtual-office-hours","title":"Virtual Office Hours","text":"<p>If it is a general-purpose question, an answer to which will be useful to other students, then a student must post it via virtual office hours on the blackboard discussions page. Virtual Office Hours is not a place for asking for specific help/guidance about your assignments (e.g. how to fix this or that error). Before posting, a student should check if:</p> <ul> <li>a similar question has already been asked by another student or not.</li> <li>the question has a meaningful title (for other students to navigate through).</li> <li>the answer can't easily be found with the help of google or other resources.</li> </ul>"},{"location":"general/communication/#emails","title":"Emails","text":"<p>If it is a personal (private) question, then a student should opt for an email. Emails should follow the provided template (see below) and have all the relevant emails in carbon copy (CC). For example, in case of writing an individual question to your instructor, you should put all co-instructor emails in CC. In case of writing an email regarding your team project, you should put all co-instructor AND all teammate emails in CC. </p> <p>Your emails should have a meaningful title (subject), introduction, body, and signature. The following is one possible template that you can use in your daily email conversations. You can automatically generate it for yourselves for ADA University. .</p>"},{"location":"general/communication/#extra-tips","title":"Extra tips","text":"<p>You can have different signatures for different courses or different emails. You can also use your signatures as your email templates. You can set up and use your signatures by clicking on the pen icon above your email (in Outlook, after clicking New Email), so that you won\u2019t have to copy-paste it every time.</p> <p>If your instructor has a Ph.D. degree, then refer to your instructor as Dr. or Professor. Otherwise, use Mr./Ms. (unless the person you are writing an email to has a title, such as M.D.). Use only surname immediately after.</p> <p>In case of requesting something, use the phrase \u201cThanks in advance\u201d at the end of your email in order to not write single-line and unnecessary \u201cThank you\u201d emails. Avoid excess emails and do not use Outlook as a chat box.</p> <p>Do not click REPLY ALL when your reply concerns only the sender. Use REPLY instead. Learn to make proper use of forwarding an email when necessary. See the official Microsoft instructions on the matter. You can also flag or pin important emails if you wish.</p>"},{"location":"general/resources/","title":"Policies &amp; Resources","text":"<p>ADA University has her university-wide policy documents. You are expected to carefully study at least the following short documents: Honor Code and Student Code of Conduct. You should also be aware of the Student Assessment Regulations. If you have strong reasons to disagree with the grade you got, you should follow the procedures written in Student Academic Grievance Policy. </p> <p>Students with special needs or with chronic health issues are strongly recommended to contact the University\u2019s Student Academic Support Services. ADA University provides upon request appropriate academic accommodations for qualified students with documented disabilities. Any student who feels (s)he may need accommodation based on the impact of a disability should notify the Office of Disability Services and Inclusive Education about their needs before the start of the academic term.<sup>1</sup></p> <p>Adjusting to student life, pursuing academic and personal goals can be emotionally stressful and challenging. Students are encouraged to make individual appointments with a Counselor to receive professional psychological support.</p> <p>Students are encouraged to consult with the Writing Center for checking their papers and assignments. Please visit the center or contact them by email. Reasonable accommodation is possible for students\u2019 religious beliefs, observations, and practices or for foreseeable conflicts because of athletic competition. Students with recurring or permanent internet and/or hardware problems are strongly recommended to contact the University\u2019s IT Service Desk and/or the Blackboard Administrator.</p> <ol> <li> <p>Contact information of different services is provided in the course Syllabus shared via Blackboard.\u00a0\u21a9</p> </li> </ol>"},{"location":"projects/01_project/","title":"Project 1","text":"<p>In this SITE 1101 team project, students explore how computer hardware works by physically building and testing basic digital logic. The project focuses on constructing NOT, AND, and OR logic gates from scratch using transistors, resistors, LEDs, and a breadboard in our beautiful lab room B012 managed by our great Lab Coordinator Nariman Vahabli. Bonus tasks extend learning by combining gates to create NAND and XOR logic through collaboration. Below are some of the finest videos by students.</p> Team 30: Suat Hamzali, Arif Badalov, Mahammad Sheykhov, Shakir Badalzada Fall 2025 Team 18: Kamal Badalzada, Aliyiyakbar Shirinli, Sonakhanim Dadashova, Zeynab Ajalova Fall 2025 Team 14: Hamayil Mammadova, Ilaha Mikayilova, Nihad Alakbarli, Shahin Guliyev Fall 2025 Team 81: Huseyn Huseynzada, Gulnar Feyzullayeva, Kamran Gafarli, Gulu Guseinov Fall 2025 Team 12: Gulshan Aliyeva, Aytaj Mirzazada, Narmin Bakirzada, Zeynal Ismayilzada Fall 2025 Team 37: Sami Karimli, Aytaj Aliyeva, Mahammad Mirzayev, Ali Aliyev Fall 2025 Team 39: Muhammad Muradov, Amil Isgandarov, Saleh Abbasov, Zaur Mirzaliyev Fall 2025"},{"location":"projects/02_project/","title":"Project 2","text":"<p>Info</p> <p>The page is under construction. Please check again later.</p>"},{"location":"projects/03_project/","title":"Project 3","text":"<p>Info</p> <p>The page is under construction. Please check again later.</p>"},{"location":"projects/04_project/","title":"Project 4","text":"<p>Info</p> <p>The page is under construction. Please check again later.</p>"}]}